MODULE LineServer;  (*NW 18.4.89 / 15.9.93*)	IMPORT SYSTEM, Core, V24, FileDir, Files, Texts, Oberon;(*packet types:  0ttt00rs	1 = data,  2 = data ack,	3 = open,  4 = open ack,	5 = close,  6 = close ack,	7 = abort *)		CONST PakSize = 256; maxLen = 1000000;		T0 = 1500;  (*timeout 5 sec*)		ENQ = 40X; SND = 41X; REC = 42X; FDIR = 45X; NPW = 48X; DEL = 49X;		MDIR = 4AX; SML = 4BX; RML = 4CX; DML = 4DX;		ACK = 10X; NAK = 25X; NPR = 26X; CX = 63X;	VAR W: Texts.Writer;		handler: Oberon.Task;		Lstat: INTEGER;  (*1: busy, 0: free*)		Lmode: INTEGER;  (*1: master, 0: server*)		rx, K: INTEGER;  (*receiver buffer index*)		rbuf: ARRAY PakSize+4 OF CHAR;  (*receiver buffer*)		myR, myS: INTEGER;  (*receiver and sender sequence numbers*)		mailuno, logcnt: INTEGER;		mailTime: LONGINT;		MF: Files.File;  (*last mail file accessed*)		hdch: ARRAY 2 OF CHAR;		cx400: ARRAY 14 OF CHAR;		buf: ARRAY 512 OF CHAR;  (*mailbox and filedir commands*)	PROCEDURE EOL;	BEGIN Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)	END EOL;	PROCEDURE Log(ch: CHAR);	BEGIN Texts.Write(W, ch); INC(logcnt);		IF logcnt = 80 THEN Texts.WriteLn(W); logcnt := 0 END ;		Texts.Append(Oberon.Log, W.buf)	END Log;	PROCEDURE Rec(VAR ch: CHAR);		VAR time: LONGINT; ch1: CHAR;	BEGIN time := Oberon.Time() + T0;		LOOP			IF V24.Available() > 0 THEN V24.Receive(ch1); ch := CHR(ORD(ch1) MOD 80H); EXIT END ;			IF Oberon.Time() > time THEN ch := 1X; EXIT END		END	END Rec;	PROCEDURE SendPacket(typ, len: INTEGER; VAR data: ARRAY OF CHAR);		VAR i, u, x: INTEGER; cs: LONGINT;	BEGIN V24.Send(hdch[1-Lmode]);		cs := typ + 5; i := 0;		WHILE i < len DO			cs := (cs*5 + ORD(data[i])) MOD 32767; INC(i)		END ;		data[len] := CHR(cs); data[len+1] := CHR(cs DIV 100H); INC(len, 2);		V24.Send(CHR(typ MOD 64 + 33)); x := typ DIV 64; u := 1; i := 0;		WHILE i < len DO  (*encode*)			IF u = 0 THEN				x := ORD(data[i]); V24.Send(CHR(x MOD 64 + 33)); x := x DIV 64; u := 1			ELSIF u = 1 THEN				x := ORD(data[i])*4 + x; V24.Send(CHR(x MOD 64 + 33)); x := x DIV 64; u := 2			ELSIF u = 2 THEN				x := ORD(data[i])*16 + x; V24.Send(CHR(x MOD 64 + 33)); V24.Send(CHR(x DIV 64 + 33)); u := 0			END ;			INC(i)		END ;		IF u > 0 THEN V24.Send(CHR(x MOD 64 + 33)) END ;		V24.Send(0DX)	END SendPacket;	PROCEDURE ReceivePacket(VAR typ, len: INTEGER);		VAR ch: CHAR;			i, j, u, x: INTEGER; cs: LONGINT;	BEGIN len := 0; typ := 0; rbuf[1] := 0X;		REPEAT Rec(ch) UNTIL ch > 0X;		IF ch = hdch[Lmode] THEN			Rec(ch); i := 0; u := 0;			WHILE (ch > 0DX) & (i < 260) DO				IF u = 0 THEN					x := ORD(ch) - 33; Rec(ch); x := (ORD(ch) - 33) * 64 + x;					rbuf[i] := CHR(x); INC(i); x := x DIV 256; u := 2				ELSIF u = 1 THEN					x := (ORD(ch) - 33) * 4 + x; rbuf[i] := CHR(x); INC(i); u := 0				ELSIF u = 2 THEN					x := (ORD(ch) - 33) * 16 + x; rbuf[i] := CHR(x); INC(i); x := x DIV 256; u := 1				END ;				Rec(ch)			END ;			IF (ch = 0DX) & (i > 2) THEN				DEC(i, 2); j := 0; cs := 1;				WHILE j < i DO					cs := (cs*5 + ORD(rbuf[j])) MOD 32767; INC(j)				END ;				IF (CHR(cs) = rbuf[i]) & (CHR(cs DIV 256) = rbuf[i+1]) THEN					rx := 1; typ := ORD(rbuf[0]); len := i-1				END			END		END	END ReceivePacket;	PROCEDURE Send1(len: INTEGER; VAR buf: ARRAY OF CHAR; VAR res: INTEGER);		VAR retries, typ, plen: INTEGER;	BEGIN myS := 1 - myS; retries := 3;		SendPacket(myR*2+myS+14H, len, buf);		LOOP ReceivePacket(typ, plen);			IF typ <= 0 THEN (*error*) DEC(retries);				IF retries = 0 THEN res := 1; EXIT END ;				SendPacket(myR*2+myS+14H, len, buf)			ELSIF (typ DIV 10H = 2) & (typ DIV 2 MOD 2 = myS) THEN res := 0; EXIT			ELSIF typ DIV 10H = 7 THEN (*abort*) res := 2; Lstat := 0; EXIT			END		END	END Send1;	PROCEDURE Receive1(VAR len, res: INTEGER);		VAR typ: INTEGER; dmy: ARRAY 4 OF CHAR;	BEGIN		LOOP ReceivePacket(typ, len);			IF typ <= 0 THEN (*error*) res := 1; EXIT			ELSIF typ DIV 10H = 1 THEN (*data*)				IF typ MOD 2 # myR THEN					myR := 1 - myR; SendPacket(myR*2+myS+20H, 0, dmy); res := 0; EXIT				ELSE SendPacket(myR*2+myS+20H, 0, dmy)				END			ELSIF typ DIV 10H = 3 THEN (*open*) SendPacket(40H, 0, dmy)			END		END	END Receive1;	PROCEDURE SendData(F: Files.File; VAR res: INTEGER);		VAR  k: INTEGER; x: CHAR;			R: Files.Rider;			buf: ARRAY PakSize+4 OF CHAR;	BEGIN Files.Set(R, F, 0);		REPEAT k := 0;			LOOP Files.Read(R, x);				IF R.eof THEN EXIT END ;				buf[k] := x; INC(k);				IF k = PakSize THEN EXIT END			END ;			Send1(k, buf, res);		UNTIL (res # 0) OR (k < PakSize)	END SendData;	PROCEDURE SendMail(VAR R: Files.Rider; len: LONGINT; VAR res: INTEGER);		VAR  k, m, typ: INTEGER; x: CHAR;			buf: ARRAY PakSize+4 OF CHAR;	BEGIN		REPEAT k := 0;			LOOP Files.Read(R, x);				IF k = len THEN EXIT END ;				buf[k] := SYSTEM.VAL(CHAR, SYSTEM.ROT(x, 3)); INC(k);				IF k = PakSize THEN EXIT END			END ;			Send1(k, buf, res); len := len - k		UNTIL (res # 0) OR (k < PakSize)	END SendMail;	PROCEDURE ReceiveData(F: Files.File; VAR L: LONGINT; VAR res: INTEGER);		VAR k, len: INTEGER;			R: Files.Rider;	BEGIN Files.Set(R, F, 0); L := 0;		LOOP Receive1(len, res);			IF res = 0 THEN				L := L + len; k := 0;				IF L > maxLen THEN Log("$"); res := 1; EXIT END ;				WHILE k < len DO					Files.Write(R, rbuf[rx]); INC(rx); INC(k)				END ;				IF k < 256 THEN EXIT END			ELSE EXIT			END		END	END ReceiveData;	PROCEDURE SendBuffer(VAR res: INTEGER);		VAR s, d: INTEGER; B0, B1: CHAR;	BEGIN B0 := buf[PakSize]; B1 := buf[PakSize+1];		Send1(PakSize, buf, res); buf[PakSize] := B0; buf[PakSize+1] := B1;		d := 0; s := PakSize;		WHILE s < K DO buf[d] := buf[s]; INC(d); INC(s) END ;		K := d	END SendBuffer;	PROCEDURE SendToSun(VAR res: INTEGER);		VAR len, uno: INTEGER;			id: Core.ShortName;			F: Files.File;	BEGIN		LOOP			IF Core.LineQueue.n = 0 THEN Send1(0, id, res); EXIT END ;			Core.GetTask(Core.LineQueue, F, id, uno); Log(".");			SendData(F, res);			IF res # 0 THEN EXIT END ;			Receive1(len, res);			IF res # 0 THEN EXIT END ;			Core.RemoveTask(Core.LineQueue)		END	END SendToSun;	PROCEDURE ReceiveFromSun(VAR res: INTEGER);	VAR len: LONGINT;			ch: CHAR;			id: Core.ShortName;			F: Files.File;	BEGIN id := "sun";		LOOP F := Files.New(""); ReceiveData(F, len, res);			IF (len = 0) OR (res # 0) THEN EXIT END ;			Files.Close(F); Log(".");			Core.InsertTask(Core.MailQueue, F, id, -1); Send1(0, id, res)		END	END ReceiveFromSun;	PROCEDURE AppendS(VAR s, d: ARRAY OF CHAR; VAR k: INTEGER);		VAR i: INTEGER; ch: CHAR;	BEGIN i := 0;		REPEAT ch := s[i]; d[k] := ch; INC(i); INC(k) UNTIL ch = 0X	END AppendS;	PROCEDURE AppendW(s: LONGINT; VAR d: ARRAY OF CHAR; n: INTEGER; VAR k: INTEGER);		VAR i: INTEGER;	BEGIN i := 0;		REPEAT d[k] := CHR(s); s := s DIV 100H; INC(i); INC(k) UNTIL i = n	END AppendW;	PROCEDURE AppendN(x: LONGINT; VAR d: ARRAY OF CHAR; VAR k: INTEGER);		VAR i: INTEGER; u: ARRAY 8 OF CHAR;	BEGIN i := 0;		REPEAT u[i] := CHR(x MOD 10 + 30H); INC(i); x := x DIV 10 UNTIL x = 0;		REPEAT DEC(i); d[k] := u[i]; INC(k) UNTIL i = 0	END AppendN;	PROCEDURE AppendDate(t, d: INTEGER; VAR buf: ARRAY OF CHAR; VAR k: INTEGER);		PROCEDURE Pair(ch: CHAR; x: LONGINT);		BEGIN buf[k] := ch; INC(k);			buf[k] := CHR(x DIV 10 + 30H); INC(k); buf[k] := CHR(x MOD 10 + 30H); INC(k)		END Pair;	BEGIN		Pair(" ", d MOD 20H); Pair(".", d DIV 20H MOD 10H); Pair(".", d DIV 200H MOD 80H);		Pair(" ", t DIV 800H MOD 20H); Pair(":", t DIV 20H MOD 40H); Pair(":", t MOD 20H * 2)	END AppendDate;	PROCEDURE* AppendDirEntry(name: FileDir.FileName; adr: LONGINT; VAR cont: BOOLEAN);		VAR i, res: INTEGER;	BEGIN i := 0;		WHILE name[i] > 0X DO buf[K] := name[i]; INC(K); INC(i) END ;		buf[K] := 0DX; INC(K);		IF K >= PakSize THEN SendBuffer(res);			IF res # 0 THEN cont := FALSE END		END	END AppendDirEntry;	PROCEDURE PickS(VAR s: ARRAY OF CHAR);		VAR i: INTEGER; ch: CHAR;	BEGIN i := 0;		REPEAT ch := rbuf[rx]; INC(rx); s[i] := ch; INC(i) UNTIL ch = 0X	END PickS;	PROCEDURE PickW(VAR w: ARRAY OF SYSTEM.BYTE; n: INTEGER);		VAR i: INTEGER;	BEGIN i := 0;		REPEAT w[i] := rbuf[rx]; INC(rx); INC(i) UNTIL i = n	END PickW;(* ---------------------- Kometh communication ------------------------ *)	PROCEDURE sendV24(s: ARRAY OF CHAR);		VAR i: INTEGER;	BEGIN i := 0;		WHILE s[i] > 0X DO V24.Send(s[i]); INC(i) END ;		V24.Send(0DX)	END sendV24;	PROCEDURE wait(t: LONGINT);	BEGIN t := Oberon.Time() + t;		REPEAT UNTIL Oberon.Time() > t	END wait;	PROCEDURE clearInput;		VAR ch: CHAR;	BEGIN		WHILE V24.Available() > 0 DO V24.Receive(ch) END ;		V24.Send(0DX)	END clearInput;	PROCEDURE Reply(repl: ARRAY OF CHAR; term: CHAR; VAR res: INTEGER);		VAR i, j, k: INTEGER; ch: CHAR;			buf: ARRAY PakSize OF CHAR;	BEGIN i := 0; res := 1;		REPEAT Rec(ch) UNTIL ch <= 0AX;		k := 0;		REPEAT Rec(ch); buf[k] := ch; INC(k)		UNTIL (ch = term) OR (ch = 1X) OR (k = 128);		IF ch = term THEN i := 0;			LOOP j := 0;				LOOP					IF repl[j] = 0X THEN res := 0; EXIT END ;					IF buf[i+j] # repl[j] THEN EXIT END ;					INC(j)				END ;				IF res = 0 THEN EXIT END ;				INC(i);				IF i+j >= k THEN EXIT END			END ;		END	END Reply;	PROCEDURE CloseMailLine*;		VAR res: INTEGER; ch: CHAR;	BEGIN V24.Break;		REPEAT Rec(ch) UNTIL (ch = "#") OR (ch = 1X);		sendV24("do "); Reply("CLOSED", ",", res);		wait(200); clearInput	END CloseMailLine;	PROCEDURE CallMailer*;		VAR ch: CHAR;			typ, plen, res, retries: INTEGER;			dmy: ARRAY 4 OF CHAR;	BEGIN		IF Lstat = 1 THEN RETURN END ;		sendV24("CALL 122B,1"); Reply("completed", 0AX, res);		IF res = 0 THEN 			sendV24("cerestst"); Reply("login", ":", res); Reply("Password", ":", res);			IF res = 0 THEN				sendV24("ik26ar"); Rec(ch);				IF ch = 0DX THEN wait(1200) ELSE res := 3 END			END ;			IF res # 0 THEN CloseMailLine END		END ;		Texts.Append(Oberon.Log, W.buf);		clearInput;		IF res = 0 THEN			Log("{"); Lmode := 1; myS := 0; myR := 0; retries := 3;			LOOP SendPacket(30H, 11, cx400); ReceivePacket(typ, plen);				IF typ DIV 10H = 4 THEN res := 0; EXIT END ;				IF typ DIV 10H = 7 THEN res := 2; EXIT END ;				DEC(retries);				IF retries = 0 THEN res := 1; EXIT END			END ;			IF res = 0 THEN				SendToSun(res);				IF res = 0 THEN Log("|") ELSE Log("-") END ;				IF res = 0 THEN ReceiveFromSun(res) END ;				SendPacket(50H, 0, dmy); ReceivePacket(typ, plen)  (*close*)			END ;			IF res = 0 THEN Log("}") ELSE Log(")") END ;			CloseMailLine; mailTime := Oberon.Time() + 90000;  (*5 min*)			Lmode := 0		ELSE (*mail line cannot be opened, try again in 5 min*)			mailTime := Oberon.Time() + 90000;			IF res = 3 THEN Log("-") ELSE Log("~") END		END	END CallMailer;(* -------------------------------Server-------------------------------*)	PROCEDURE* Serve;		VAR typ, plen, res, retries, i, j, k, kd, ks, n, uno: INTEGER;			ch, B0, B1: CHAR;			F: Files.File;			R: Files.Rider;			pos, len, flen, pw, npw: LONGINT;			Id: Core.ShortName;			fname: Core.Name;			mrtab: Core.MResTab;			mdir: Core.MailDir;		PROCEDURE Reply(ch: CHAR);			VAR msg: ARRAY 4 OF CHAR;		BEGIN msg[0] := ch; Send1(1, msg, res)		END Reply;	BEGIN		IF V24.Available() > 4 THEN			Lmode := 0; ReceivePacket(typ, plen);			IF typ DIV 10H = 3 THEN  (*open*)				Lstat := 1; myS := 0; myR := 0; SendPacket(40H, 0, Id);				ch := rbuf[rx]; INC(rx);				IF ch = SND THEN (*send file*)					PickS(Id); PickW(pw, 4); PickS(fname);					IF Core.UserNo(Id, pw) >= 0 THEN						F := Files.Old(fname);						IF F # NIL THEN Reply(ACK); SendData(F, res) ELSE Reply(NAK) END					ELSE Reply(NPR)					END				ELSIF ch = REC THEN (*receive file*)					PickS(Id); PickW(pw, 4); PickS(fname);					IF Core.UserNo(Id, pw) >= 0 THEN						F := Files.New(fname);						Reply(ACK); ReceiveData(F, len, res);						IF res = 0 THEN Files.Register(F) END					ELSE Reply(NPR)					END				ELSIF ch = DEL THEN					PickS(Id); PickW(pw, 4); PickS(fname);					IF Core.UserNo(Id, pw) >= 0 THEN						Files.Delete(fname, res);						IF res = 0 THEN Reply(ACK) ELSE Reply(NAK) END					ELSE Reply(NPR)					END				ELSIF ch = FDIR THEN					PickS(Id); PickW(pw, 4); PickS(fname); uno := Core.UserNo(Id, pw);					IF uno >= 0 THEN						Reply(ACK); K := 0; FileDir.Enumerate(fname, AppendDirEntry); Send1(K, buf, res)					ELSE Reply(NPR)					END				ELSIF ch = MDIR THEN (*send mail directory*)					PickS(Id); PickW(pw, 4); uno := Core.UserNo(Id, pw);					IF uno >= 0 THEN						IF uno # mailuno THEN							Core.GetFileName(uno, fname); MF := Files.Old(fname); mailuno := uno						END ;						IF MF # NIL THEN							Reply(ACK); Files.Set(R, MF, 32); Files.ReadBytes(R, mdir, SIZE(Core.MailDir));							K := 0; res := 0; i := mdir[0].next;							WHILE (i > 0) & (res = 0) DO								AppendN(i, buf, K); AppendDate(mdir[i].time, mdir[i].date, buf, K);								buf[K] := " "; INC(K); AppendS(mdir[i].originator, buf, K);								buf[K-1] := " "; AppendN(mdir[i].len, buf, K); buf[K] := 0DX; INC(K);								IF K >= PakSize THEN SendBuffer(res) END ;								i := mdir[i].next							END ;							Send1(K, buf, res)						ELSE Reply(NAK)						END					ELSE Reply(NPR)					END				ELSIF ch = SML THEN (*send mail*)					PickS(Id); PickW(pw, 4); PickW(n, 2);					uno := Core.UserNo(Id, pw);					IF uno >= 0 THEN						IF uno # mailuno THEN							Core.GetFileName(uno, fname); MF := Files.Old(fname); mailuno := uno						END ;						IF (MF # NIL) & (n > 0) & (n < 31) THEN							Files.Set(R, MF, (n+1)*32);							Files.ReadBytes(R, pos, 4); pos := (pos MOD 10000H) * 100H;							Files.ReadBytes(R, len, 4);							IF len > 0 THEN Reply(ACK); Files.Set(R, MF, pos); SendMail(R, len, res)							ELSE Reply(NAK)							END						ELSE Reply(NAK)						END					ELSE Reply(NPR)					END				ELSIF ch = RML THEN (*receive mail*)					PickS(Id); PickW(pw, 4); uno := Core.UserNo(Id, pw);					IF uno >= 0 THEN						F := Files.New("");						IF F # NIL THEN							Reply(ACK); ReceiveData(F, len, res);							IF res = 0 THEN Files.Close(F); Core.InsertTask(Core.MailQueue, F, Id, uno) END						ELSE Reply(NAK)						END					ELSE Reply(NPR)					END				ELSIF ch = DML THEN (*delete mail*)					PickS(Id); PickW(pw, 4); PickW(n, 2); uno := Core.UserNo(Id, pw);					IF uno >= 0 THEN						IF uno # mailuno THEN							Core.GetFileName(uno, fname); MF := Files.Old(fname); mailuno := uno						END ;						IF (MF # NIL) & (n > 0) & (n < 31) THEN							Files.Set(R, MF, 0);							Files.ReadBytes(R, mrtab, 32); Files.ReadBytes(R, mdir, SIZE(Core.MailDir));							i := 0;							LOOP k := mdir[i].next;								IF k = n THEN									j := mdir[n].pos;									k := SHORT((mdir[n].len + 255) DIV 256) + j;									REPEAT INCL(mrtab[j DIV 32], j MOD 32); INC(j) UNTIL j = k;									mdir[n].len := 0; mdir[i].next := mdir[n].next;									Files.Set(R, MF, 0); Files.WriteBytes(R, mrtab, 32);									Files.WriteBytes(R, mdir, SIZE(Core.MailDir)); Files.Close(MF);									Reply(ACK); EXIT								END ;								IF k = 0 THEN Reply(NAK); EXIT END ;								i := k							END						ELSE Reply(NAK)						END					ELSE Reply(NPR)					END				ELSIF ch = NPW THEN					PickS(Id); PickW(pw, 4); PickW(npw, 4);					IF Core.UserNo(Id, pw) >= 0 THEN Core.SetPassword(uno, npw); Reply(ACK)					ELSE Reply(NAK)					END				ELSIF ch = CX THEN					Log("["); ReceiveFromSun(res);					IF res = 0 THEN Log("|") ELSE Log("-") END ;					IF res = 0 THEN SendToSun(res) END ;					IF res = 0 THEN						ReceivePacket(typ, plen); Log("]");  (*close*)						IF typ DIV 10H = 5 THEN SendPacket(60H, 0, buf) END					ELSE Log(")")					END ;					Lstat := 0				END			ELSIF typ DIV 10H = 5 THEN  (*close*)				SendPacket(60H, 0, buf); Lstat := 0; MF := NIL; mailuno := -2; len := Oberon.Time() + T0;				IF len > mailTime THEN mailTime := len END			ELSIF typ DIV 10H = 7 THEN  (*abort*) Lstat := 0			END ;			Core.Collect(*		ELSIF (Core.ExportQueue.n >= 4) & (Oberon.Time() > mailTime) THEN CallMailer  *)		END	END Serve;	(*------------------------- Commands -------------------------*)	PROCEDURE Start*;	BEGIN Lstat := 0; Lmode := 0; rx := 0; logcnt := 0;		Oberon.Remove(handler); Oberon.Install(handler);		Texts.WriteString(W, "Line started  (NW 15.9.93)"); EOL	END Start;	PROCEDURE Reset*;	BEGIN  Lmode := 0; Lstat := 0; rx := 0; logcnt := 0; mailTime := 0;		V24.Start(0BBX, 13X, 7X); Texts.WriteString(W, "Line reset"); EOL	END Reset;	PROCEDURE State*;	BEGIN Texts.WriteString(W, "Line queue:"); Texts.WriteInt(W, Core.LineQueue.n, 3); EOL	END State;	PROCEDURE Stop*;	BEGIN Oberon.Remove(handler); Texts.WriteString(W, "Line stopped"); EOL	END Stop;	PROCEDURE SendCmd*;		VAR ch: CHAR;			S: Texts.Reader;	BEGIN Texts.OpenReader(S, Oberon.Par.text, Oberon.Par.pos);		REPEAT Texts.Read(S, ch) UNTIL ch # " ";		WHILE ch >= " " DO V24.Send(ch); Texts.Read(S, ch) END ;		V24.Send(0DX) 	END SendCmd;BEGIN Texts.OpenWriter(W); hdch[0] := "{"; hdch[1] := "}"; cx400 := "cx400 pluto";	mailuno := -2; V24.Start(0BBX, 13X, 7X); NEW(handler); handler.handle := ServeEND LineServer.