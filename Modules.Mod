MODULE  Modules;  (*NW 16.2.86 / 22.9.92*)    IMPORT SYSTEM, Kernel, Files;    CONST ModNameLen* = 24; ObjMark = 0F5X; maximps = 32; headersize = 64;    TYPE Module* = POINTER TO ModDesc;         Command* = PROCEDURE;         ModuleName* = ARRAY ModNameLen OF CHAR;        ModDesc* = RECORD            next*: Module;            size*, IB*, EB*, RB*, CB*, PB*, refcnt*, key*: LONGINT;            name*: ModuleName        END ;    VAR res*: INTEGER;        importing*, imported*: ModuleName;        loop: Command;    (*Exported procedures: ThisMod, Free, ThisProc*)    PROCEDURE ReadName(VAR R: Files.Rider; VAR s: ModuleName);        VAR ch: CHAR; i: INTEGER;    BEGIN i := 0;        REPEAT Files.Read(R, ch); s[i] := ch; INC(i)        UNTIL ch = 0X    END ReadName;    PROCEDURE OpenFile(VAR F: Files.File; VAR name: ARRAY OF CHAR);        VAR i: INTEGER; ch: CHAR;            Fname: ARRAY 32 OF CHAR;    BEGIN i := 0; ch := name[0]; (*make file name*)        WHILE ch > 0X DO Fname[i] := ch; INC(i); ch := name[i] END ;        Fname[i] := "."; Fname[i+1] := "o"; Fname[i+2] := "b"; Fname[i+3] := "j"; Fname[i+4] := 0X;        F := Files.Old(Fname)    END OpenFile;    PROCEDURE disp(a: LONGINT): LONGINT;        VAR d: LONGINT; i: INTEGER;    BEGIN d := 0; a := a MOD 40000000H + 0C0000000H; i := 0;        REPEAT d := SYSTEM.LSH(d, 8) + (a MOD 100H); a := SYSTEM.LSH(a, -8); INC(i)        UNTIL i = 4;        RETURN d    END disp;    PROCEDURE ThisMod*(name: ARRAY OF CHAR): Module;        (*search module in list; if not found, load module*)        VAR            mod, impmod, desc: Module;            ch: CHAR; k: SHORTINT;            i, j, offset, align, tdsize, tdadr: INTEGER;            nofimps, nofentries, nofptrs, comsize, constsize, codesize, nofrecs: INTEGER;            size, varsize, key, impkey, p, q, pb, eb: LONGINT;            init: Command;            F: Files.File; R: Files.Rider;            impname, modname: ModuleName;            import: ARRAY maximps OF Module;        PROCEDURE err(n: INTEGER);        BEGIN res := n; COPY(name, importing)        END err;    BEGIN res := 0; mod := SYSTEM.VAL(Module, Kernel.ModList);        LOOP            IF name = mod.name THEN EXIT END ;            mod := mod.next;            IF mod = NIL THEN EXIT END        END ;        IF mod = NIL THEN (*load*)            OpenFile(F, name);            IF F # NIL THEN                Files.Set(R, F, 0); Files.Read(R, ch); (*header*)                IF ch # ObjMark THEN err(2); RETURN NIL END ;                Files.Read(R, ch); Files.ReadBytes(R, varsize, 4);  (*skip*)                Files.ReadBytes(R, nofimps, 2); Files.ReadBytes(R, nofentries, 2);                Files.ReadBytes(R, nofptrs, 2); Files.ReadBytes(R, comsize, 2);                Files.ReadBytes(R, constsize, 2); Files.ReadBytes(R, varsize, 4);                Files.ReadBytes(R, codesize, 2); Files.ReadBytes(R, nofrecs, 2);                Files.ReadBytes(R, key, 4); ReadName(R, modname);                align := (-((nofentries + nofptrs)*2 + comsize)) MOD 4;                (*imports*) res := 0; i := 0;                WHILE (i < nofimps) & (res = 0) DO                    Files.ReadBytes(R, impkey, 4); ReadName(R, impname);                    impmod := ThisMod(impname);                    IF res = 0 THEN                        IF impmod.key = impkey THEN import[i] := impmod; INC(i); INC(impmod.refcnt)                        ELSE err(3); imported := impname                        END                    END                END ;                IF res # 0 THEN (*undo*)                    WHILE i > 0 DO DEC(i); DEC(import[i].refcnt) END ;                    RETURN NIL                END ;                size := headersize + (nofentries +  nofptrs)*2 + nofimps*4 + comsize +                     varsize + codesize + constsize + align;                Kernel.AllocBlock(p, size); mod := SYSTEM.VAL(Module, p);                IF p = 0 THEN err(7); RETURN NIL END ;                mod.size := size;                mod.IB := p + headersize;                mod.EB := mod.IB + nofimps*4;                mod.RB := mod.EB + nofentries*2;                mod.CB := mod.RB + nofptrs*2;                mod.PB := mod.CB + comsize + align + constsize + varsize;                mod.refcnt := 0; mod.key := key;                COPY(modname, mod.name);                p := mod.IB; i := 0;                WHILE i < nofimps DO SYSTEM.PUT(p, import[i]); INC(p, 4); INC(i) END ;                (*entries*) q :=  nofentries*2 + p;                WHILE p < q DO Files.ReadBytes(R, i, 2); SYSTEM.PUT(p, i); INC(p, 2) END ;                (*pointer references*) q := nofptrs*2 + p;                WHILE p < q DO                    Files.ReadBytes(R, i, 2); SYSTEM.PUT(p, i); INC(p, 2)                END ;                (*commands*) q := p + comsize;                WHILE p < q DO Files.Read(R, ch); SYSTEM.PUT(p, ch); INC(p) END ;                p := p + align;                (*constants*) q := p + constsize;                WHILE p < q DO Files.Read(R, ch); SYSTEM.PUT(p, ch); INC(p) END ;                (*variables*) q := p + varsize;                WHILE p < q DO SYSTEM.PUT(p, 0); INC(p) END ;                (*code*) q := p + codesize;                WHILE p < q DO Files.Read(R, ch); SYSTEM.PUT(p, ch); INC(p) END ;                (*link*) i := 0;                WHILE i < nofimps DO                    pb := import[i].PB; eb := import[i].EB;                    Files.ReadBytes(R, offset, 2); p := offset;                    WHILE p # 0 DO  (*abs chain*)                        INC(p, mod.PB); SYSTEM.GET(p, q);                        SYSTEM.GET((q DIV 100H) MOD 100H * 2 + eb, offset);                        SYSTEM.PUT(p, disp(pb + offset)); p := q DIV 10000H                    END ;                    Files.ReadBytes(R, offset, 2); p := offset;                    WHILE p # 0 DO  (*pc-rel chain*)                        INC(p, mod.PB); SYSTEM.GET(p, q);                        SYSTEM.GET((q DIV 100H) MOD 100H * 2 + eb, offset);                        SYSTEM.PUT(p, disp((pb + offset) - (p - 1))); p := q DIV 10000H                    END ;                    INC(i)                END ;                (*type descriptors*) i := 0;                WHILE i < nofrecs DO                    Files.ReadBytes(R, tdsize, 2); Files.ReadBytes(R, tdadr, 2);                    SYSTEM.NEW(desc, tdsize); SYSTEM.PUT(mod.PB + tdadr, desc);                    p := SYSTEM.VAL(LONGINT, desc);                    Files.ReadBytes(R, size, 4); SYSTEM.PUT(p, size); INC(p, 4);   (*header*)                    Files.Read(R, k); j := 0;                    WHILE j < k DO (*base tags*)                        Files.Read(R, ch); Files.ReadBytes(R, q, 4); (*offset or eno*)                        IF ch = 0X THEN INC(q, mod.PB)                        ELSE SYSTEM.GET(import[ORD(ch)-1].EB + q*2, offset);                            q := import[ORD(ch)-1].PB + offset                        END ;                        SYSTEM.GET(q, q); SYSTEM.PUT(p, q); INC(p, 4); INC(j)                    END ;                    WHILE j < 7 DO q := 0; SYSTEM.PUT(p, q); INC(p, 4); INC(j) END ;                    Files.Read(R, k); j := 0;                    WHILE j < k DO (*offsets*)                        Files.ReadBytes(R, offset, 2); SYSTEM.PUT(p, offset); INC(p, 2); INC(j)                    END ;                    INC(i)                END ;                init := SYSTEM.VAL(Command, mod.PB); init; res := 0            ELSE COPY(name, imported); err(1)            END        END ;        RETURN mod    END ThisMod;    PROCEDURE ThisCommand*(mod: Module; name: ARRAY OF CHAR): Command;        VAR i: INTEGER; ch: CHAR;                comadr: LONGINT; com: Command;    BEGIN com := NIL;        IF mod # NIL THEN            comadr := mod.CB; res := 5;            LOOP SYSTEM.GET(comadr, ch); INC(comadr);                IF ch = 0X THEN (*not found*) EXIT END ;                i := 0;                LOOP                    IF ch # name[i] THEN EXIT END ;                    INC(i);                    IF ch = 0X THEN res := 0; EXIT END ;                    SYSTEM.GET(comadr, ch); INC(comadr)                END ;                IF res = 0 THEN (*match*)                    SYSTEM.GET(comadr, i); com := SYSTEM.VAL(Command, mod.PB + i); EXIT                ELSE                    WHILE ch > 0X DO SYSTEM.GET(comadr, ch); INC(comadr) END ;                    INC(comadr, 2)                END            END        END ;        RETURN com    END ThisCommand;    PROCEDURE unload(mod: Module; all: BOOLEAN);        VAR p: LONGINT; imp: Module;    BEGIN p := mod.IB;        WHILE p < mod.EB DO  (*scan imports*)            SYSTEM.GET(p, imp);            IF imp # NIL THEN                DEC(imp.refcnt);                IF all & (imp.refcnt = 0) THEN unload(imp, all) END            END ;             INC(p, 4)        END ;        Kernel.FreeBlock(SYSTEM.VAL(LONGINT, mod))    END unload;    PROCEDURE Free*(name: ARRAY OF CHAR; all: BOOLEAN);        VAR mod: Module;    BEGIN mod :=  SYSTEM.VAL(Module, Kernel.ModList);        LOOP            IF mod = NIL THEN res := 1; EXIT END ;            IF name = mod.name THEN                IF mod.refcnt = 0 THEN unload(mod, all); res := 0 ELSE res := 2 END ;                EXIT            END ;            mod := mod.next        END    END Free;BEGIN    IF Kernel.err = 0 THEN loop := ThisCommand(ThisMod("Oberon"), "Loop") END ;    loopEND Modules.