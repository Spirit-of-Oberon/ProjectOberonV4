MODULE Compiler;   (*NW 7.6.87 / 21.8.92 / 14.12.93*)	IMPORT SYSTEM, Texts, TextFrames, Viewers, Oberon, OBS, OBT, OBC, OBE, OBH;	CONST NofCases = 128; ModNameLen = 20; MaxRecs = 32;		RecDescSize = 8; AdrSize = 4; ProcSize = 4; PtrSize = 4;		XParOrg = 12; LParOrg = 8; LDataSize = 2000H;					(*symbol values*)			times = 1; slash = 2; div = 3; mod = 4;			and = 5; plus = 6; minus = 7; or = 8; eql = 9;			neq = 10; lss = 11; leq = 12; gtr = 13; geq = 14;			in = 15; is = 16; arrow = 17; period = 18; comma = 19;			colon = 20; upto = 21; rparen = 22; rbrak = 23; rbrace = 24;			of = 25; then = 26; do = 27; to = 28; lparen = 29;			lbrak = 30; lbrace = 31; not = 32; becomes = 33; number = 34;			nil = 35; string = 36; ident = 37; semicolon = 38; bar = 39;			end = 40; else = 41; elsif = 42; until = 43; if = 44;			case = 45; while = 46; repeat = 47; loop = 48; with = 49;			exit = 50; return = 51; for = 52; by = 53;			array = 54; record = 55; pointer = 56;			begin = 57; const = 58; type = 59; var = 60; procedure = 61;			import = 62; module = 63;		(*object and item modes*)			Var = 1; Ind = 3; Con = 8; Stk = 9; Stk0 = 10; Fld = 13; Typ = 14;			LProc = 15; SProc = 16; CProc = 17; IProc = 18; Mod = 19;		(*structure forms*)			Undef = 0; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6; Real = 7; LReal = 8; Set = 9; String = 10;			NilTyp = 11; NoTyp = 12; Pointer = 13; ProcTyp = 14; Array = 15; DynArr = 16; Record = 17;			intSet = {4 .. 6}; labeltyps = {3 .. 6};				VAR W: Texts.Writer;		sym, nofrecs: INTEGER;		newSF: BOOLEAN;		dsize: LONGINT;		LoopLevel, ExitNo: INTEGER;		LoopExit: ARRAY 16 OF INTEGER;	PROCEDURE^ Type(VAR typ: OBT.Struct);	PROCEDURE^ FormalType(VAR typ: OBT.Struct);	PROCEDURE^ Expression(VAR x: OBT.Item);	PROCEDURE^ Block(VAR dsize: LONGINT);	PROCEDURE CheckSym(s: INTEGER);	BEGIN		IF sym = s THEN OBS.Get(sym) ELSE OBS.Mark(s) END	END CheckSym;	PROCEDURE qualident(VAR x: OBT.Item);		VAR mnolev: INTEGER; obj: OBT.Object;	BEGIN (*sym = ident*)		OBT.Find(obj, mnolev); OBS.Get(sym);		IF (sym = period) & (obj # NIL) & (obj.mode = Mod) THEN			OBS.Get(sym); mnolev := SHORT(-obj.a0);			IF sym = ident THEN				OBT.FindImport(obj, obj); OBS.Get(sym)			ELSE OBS.Mark(10); obj := NIL			END		END ;		x.lev := mnolev; x.obj := obj;		IF obj # NIL THEN			x.mode := obj.mode; x.typ := obj.typ; x.a0 := obj.a0; x.a1 := obj.a1		ELSE OBS.Mark(0); x.mode := Var;			x.typ := OBT.undftyp; x.a0 := 0; x.obj := NIL		END	END qualident;	PROCEDURE ConstExpression(VAR x: OBT.Item);	BEGIN Expression(x);		IF x.mode # Con THEN			OBS.Mark(50); x.mode := Con; x.typ := OBT.inttyp; x.a0 := 1		END	END ConstExpression;	PROCEDURE NewStr(form: INTEGER): OBT.Struct;		VAR typ: OBT.Struct;	BEGIN NEW(typ);		typ.form := form; typ.mno := 0; typ.size := 4; typ.ref := 0;		typ.BaseTyp := OBT.undftyp; typ.strobj := NIL; RETURN typ	END NewStr;	PROCEDURE CheckMark(VAR mk: BOOLEAN);	BEGIN OBS.Get(sym);		IF sym = times THEN			IF OBC.level = 0 THEN mk := TRUE ELSE mk := FALSE; OBS.Mark(47) END ;			OBS.Get(sym)		ELSE mk := FALSE		END	END CheckMark;	PROCEDURE CheckUndefPointerTypes;		VAR obj: OBT.Object;	BEGIN obj := OBT.topScope.next;		WHILE obj # NIL DO			IF obj.mode = Undef THEN OBS.Mark(48) END ;			obj := obj.next		END	END CheckUndefPointerTypes;	PROCEDURE RecordType(VAR typ: OBT.Struct);		VAR adr, size: LONGINT;			fld, fld0, fld1: OBT.Object;			ftyp, btyp: OBT.Struct;			base: OBT.Item;	BEGIN adr := 0; typ := NewStr(Record); typ.BaseTyp := NIL; typ.extlev := 0;		IF sym = lparen THEN			OBS.Get(sym); (*record extension*)			IF sym = ident THEN				qualident(base);				IF (base.mode = Typ) & (base.typ.form = Record) THEN					typ.BaseTyp := base.typ; typ.extlev := base.typ.extlev + 1; adr := base.typ.size				ELSE OBS.Mark(52)				END			ELSE OBS.Mark(10)			END ;			CheckSym(rparen)		END ;		OBT.OpenScope(0); fld := NIL; fld1 := OBT.topScope;		LOOP			IF sym = ident THEN				LOOP					IF sym = ident THEN						IF typ.BaseTyp # NIL THEN							OBT.FindField(typ.BaseTyp, fld0);							IF fld0 # NIL THEN OBS.Mark(1) END						END ;						OBT.Insert(OBS.name, fld); CheckMark(fld.marked); fld.mode := Fld					ELSE OBS.Mark(10)					END ;					IF sym = comma THEN OBS.Get(sym)					ELSIF sym = ident THEN OBS.Mark(19)					ELSE EXIT					END				END ;				CheckSym(colon); Type(ftyp); size := ftyp.size; btyp := ftyp;				WHILE btyp.form = Array DO btyp := btyp.BaseTyp END ;				IF btyp.size >= 4 THEN INC(adr, (-adr) MOD 4)				ELSIF btyp.size = 2 THEN INC(adr, adr MOD 2)				END ;				WHILE fld1.next # NIL DO					fld1 := fld1.next; fld1.typ := ftyp; fld1.a0 := adr; INC(adr, size)				END			END ;			IF sym = semicolon THEN OBS.Get(sym)			ELSIF sym = ident THEN OBS.Mark(38)			ELSE EXIT			END		END ;		typ.size := (-adr) MOD 4 + adr; typ.mno := 0; typ.link := OBT.topScope.next;		CheckUndefPointerTypes; OBT.CloseScope;		IF OBC.level = 0 THEN INC(dsize, (-dsize) MOD 4 + 4); typ.adr := -dsize END ;		OBC.RegisterRecType(typ)	END RecordType;	PROCEDURE ArrayType(VAR typ: OBT.Struct);		VAR x: OBT.Item; f, n: INTEGER;	BEGIN typ := NewStr(Array); ConstExpression(x); f := x.typ.form;		IF f IN intSet THEN			IF x.a0 <= 0 THEN x.a0 := 1; OBS.Mark(63) END		ELSE OBS.Mark(51); x.a0 := 1		END ;		IF sym = of THEN OBS.Get(sym); Type(typ.BaseTyp)		ELSIF sym = comma THEN OBS.Get(sym); ArrayType(typ.BaseTyp)		ELSE OBS.Mark(34)		END ;		typ.size := x.a0 * typ.BaseTyp.size	END ArrayType;	PROCEDURE FormalParameters(VAR resTyp: OBT.Struct; VAR psize: LONGINT);		VAR mode: SHORTINT;			adr, size: LONGINT; res: OBT.Item;			par, par1: OBT.Object; typ: OBT.Struct;	BEGIN par1 := OBT.topScope; adr := 0;		IF (sym = ident) OR (sym = var) THEN			LOOP				IF sym = var THEN OBS.Get(sym); mode := Ind ELSE mode := Var END ;				LOOP					IF sym = ident THEN						OBT.Insert(OBS.name, par); OBS.Get(sym); par.mode := mode					ELSE OBS.Mark(10)					END ;					IF sym = comma THEN OBS.Get(sym)					ELSIF sym = ident THEN OBS.Mark(19)					ELSIF sym = var THEN OBS.Mark(19); OBS.Get(sym)					ELSE EXIT					END				END ;				CheckSym(colon); FormalType(typ);				IF mode = Ind THEN (*VAR param*)					IF typ.form = Record THEN size := RecDescSize					ELSIF typ.form = DynArr THEN size := typ.size					ELSE size := AdrSize					END				ELSE size := (-typ.size) MOD 4 + typ.size				END ;				WHILE par1.next # NIL DO					par1 := par1.next; par1.typ := typ; DEC(adr, size); par1.a0 := adr				END ;				IF sym = semicolon THEN OBS.Get(sym)				ELSIF sym = ident THEN OBS.Mark(38)				ELSE EXIT				END			END		END ;		psize := psize - adr; par := OBT.topScope.next;		WHILE par # NIL DO INC(par.a0, psize); par := par.next END ;		CheckSym(rparen);		IF sym = colon THEN			OBS.Get(sym); resTyp := OBT.undftyp;			IF sym = ident THEN qualident(res);				IF res.mode = Typ THEN					IF (res.typ.form <= ProcTyp) & (res.typ.form # NoTyp) THEN resTyp := res.typ					ELSE OBS.Mark(54)					END				ELSE OBS.Mark(52)				END			ELSE OBS.Mark(10)			END		ELSE resTyp := OBT.notyp		END	END FormalParameters;	PROCEDURE ProcType(VAR typ: OBT.Struct);		VAR psize: LONGINT;	BEGIN typ := NewStr(ProcTyp); typ.size := ProcSize;		IF sym = lparen THEN			OBS.Get(sym); OBT.OpenScope(OBC.level); psize := XParOrg;			FormalParameters(typ.BaseTyp, psize); typ.link := OBT.topScope.next;			OBT.CloseScope		ELSE typ.BaseTyp := OBT.notyp; typ.link := NIL		END	END ProcType;	PROCEDURE HasPtr(typ: OBT.Struct): BOOLEAN;		VAR fld: OBT.Object;	BEGIN		IF typ.form = Pointer THEN RETURN TRUE		ELSIF typ.form = Array THEN RETURN HasPtr(typ.BaseTyp)		ELSIF typ.form = Record THEN			IF (typ.BaseTyp # NIL) & HasPtr(typ.BaseTyp) THEN RETURN TRUE END ;			fld := typ.link;			WHILE fld # NIL DO				IF (fld.name = "") OR HasPtr(fld.typ) THEN RETURN TRUE END ;				fld := fld.next			END		END ;		RETURN FALSE	END HasPtr;	PROCEDURE SetPtrBase(ptyp, btyp: OBT.Struct);	BEGIN		IF (btyp.form = Record) OR (btyp.form = Array) & ~HasPtr(btyp.BaseTyp) THEN			ptyp.BaseTyp := btyp		ELSE ptyp.BaseTyp := OBT.undftyp; OBS.Mark(57)		END	END SetPtrBase;	PROCEDURE Type(VAR typ: OBT.Struct);		VAR lev: INTEGER; obj: OBT.Object; x: OBT.Item;	BEGIN typ := OBT.undftyp;		IF sym < lparen THEN OBS.Mark(12);			REPEAT OBS.Get(sym) UNTIL sym >= lparen		END ;		IF sym = ident THEN qualident(x);			IF x.mode = Typ THEN typ := x.typ;				IF typ = OBT.notyp THEN OBS.Mark(58) END			ELSE OBS.Mark(52)			END		ELSIF sym = array THEN OBS.Get(sym); ArrayType(typ)		ELSIF sym = record THEN OBS.Get(sym); RecordType(typ); CheckSym(end)		ELSIF sym = pointer THEN			OBS.Get(sym); typ := NewStr(Pointer); typ.link := NIL; typ.size := PtrSize;			CheckSym(to);			IF sym = ident THEN OBT.Find(obj, lev);				IF obj = NIL THEN (*forward ref*)					OBT.Insert(OBS.name, obj); typ.BaseTyp := OBT.undftyp;					obj.mode := Undef; obj.typ := typ; OBS.Get(sym)				ELSE qualident(x);					IF x.mode = Typ THEN SetPtrBase(typ, x.typ)					ELSE typ.BaseTyp := OBT.undftyp; OBS.Mark(52)					END				END			ELSE Type(x.typ); SetPtrBase(typ, x.typ)			END		ELSIF sym = procedure THEN OBS.Get(sym); ProcType(typ)		ELSE OBS.Mark(12)		END ;		IF (sym < semicolon) OR (else < sym) THEN OBS.Mark(15);			WHILE (sym <= ident) OR (else < sym) & (sym < begin) DO				OBS.Get(sym)			END		END	END Type;	PROCEDURE FormalType(VAR typ: OBT.Struct);		VAR x: OBT.Item; typ0: OBT.Struct; a, s: LONGINT;	BEGIN typ := OBT.undftyp; a := 0;		WHILE sym = array DO			OBS.Get(sym); CheckSym(of); INC(a, 4)		END ;		IF sym = ident THEN qualident(x);			IF x.mode = Typ THEN typ := x.typ;				IF typ = OBT.notyp THEN OBS.Mark(58) END			ELSE OBS.Mark(52)			END		ELSIF sym = procedure THEN OBS.Get(sym); ProcType(typ)		ELSE OBS.Mark(10)		END ;		s := a + 8;		WHILE a > 0 DO			typ0 := NewStr(DynArr); typ0.BaseTyp := typ;			typ0.size := s-a; typ0.adr := typ0.size-4; typ0.mno := 0; typ := typ0; DEC(a, 4)		END	END FormalType;	PROCEDURE selector(VAR x: OBT.Item);		VAR fld: OBT.Object; y: OBT.Item;	BEGIN		LOOP			IF sym = lbrak THEN OBS.Get(sym);				LOOP					IF (x.typ # NIL) & (x.typ.form = Pointer) THEN OBE.DeRef(x) END ;					Expression(y); OBE.Index(x, y);					IF sym = comma THEN OBS.Get(sym) ELSE EXIT END				END ;				CheckSym(rbrak)			ELSIF sym = period THEN OBS.Get(sym);				IF sym = ident THEN					IF x.typ # NIL THEN						IF x.typ.form = Pointer THEN OBE.DeRef(x) END ;						IF x.typ.form = Record THEN OBT.FindField(x.typ, fld); OBE.Field(x, fld)						ELSE OBS.Mark(53)						END					ELSE OBS.Mark(52)					END ;					OBS.Get(sym)				ELSE OBS.Mark(10)				END			ELSIF sym = arrow THEN				OBS.Get(sym); OBE.DeRef(x)			ELSIF (sym = lparen) & (x.mode < Typ) & (x.typ.form # ProcTyp) THEN				OBS.Get(sym);				IF sym = ident THEN					qualident(y);					IF y.mode = Typ THEN OBE.TypTest(x, y, FALSE) ELSE OBS.Mark(52) END				ELSE OBS.Mark(10)				END ;				CheckSym(rparen)			ELSE EXIT			END		END	END selector;	PROCEDURE IsParam(obj: OBT.Object): BOOLEAN;	BEGIN RETURN (obj # NIL) & (obj.mode <= Ind) & (obj.a0 >= 0)  (*!*)	END IsParam;	PROCEDURE ActualParameters(VAR x: OBT.Item; fpar: OBT.Object);		VAR apar: OBT.Item; R: SET;	BEGIN		IF sym # rparen THEN			R := OBC.UsedRegisters();			LOOP Expression(apar);				IF IsParam(fpar) THEN OBH.Param(apar, fpar); fpar := fpar.next				ELSE OBS.Mark(64)				END ;				OBC.FreeRegs(R);				IF sym = comma THEN OBS.Get(sym)				ELSIF (lparen <= sym) & (sym <= ident) THEN OBS.Mark(19)				ELSE EXIT				END			END		END ;		IF IsParam(fpar) THEN OBS.Mark(65) END	END ActualParameters;	PROCEDURE StandProcCall(VAR x: OBT.Item);		VAR y: OBT.Item; m, n: INTEGER;	BEGIN m := SHORT(x.a0); n := 0;		IF sym = lparen THEN OBS.Get(sym);			IF sym # rparen THEN				LOOP					IF n = 0 THEN Expression(x); OBE.StPar1(x, m); n := 1					ELSIF n = 1 THEN Expression(y); OBE.StPar2(x, y, m); n := 2					ELSIF n = 2 THEN Expression(y); OBE.StPar3(x, y, m); n := 3					ELSE OBS.Mark(64); Expression(y)					END ;					IF sym = comma THEN OBS.Get(sym)					ELSIF (lparen <= sym) & (sym <= ident) THEN OBS.Mark(19)					ELSE EXIT					END				END ;				CheckSym(rparen)			ELSE OBS.Get(sym)			END ;			OBE.StFct(x, m, n)		ELSE OBS.Mark(29)		END	END StandProcCall;	PROCEDURE Element(VAR x: OBT.Item);		VAR e1, e2: OBT.Item;	BEGIN Expression(e1);		IF sym = upto THEN			OBS.Get(sym); Expression(e2); OBE.Set1(x, e1, e2)		ELSE OBE.Set0(x, e1)		END ;	END Element;	PROCEDURE Sets(VAR x: OBT.Item);		VAR y: OBT.Item;	BEGIN x.typ := OBT.settyp; y.typ := OBT.settyp;		IF sym # rbrace THEN			Element(x);			LOOP				IF sym = comma THEN OBS.Get(sym)				ELSIF (lparen <= sym) & (sym <= ident) THEN OBS.Mark(19)				ELSE EXIT				END ;				Element(y); OBE.Op(plus, x, y)  (*x := x+y*)			END		ELSE x.mode := Con; x.a0 := 0		END ;		CheckSym(rbrace)	END Sets;	PROCEDURE Factor(VAR x: OBT.Item);		VAR fpar: OBT.Object; gR, fR: SET;	BEGIN		IF sym < lparen THEN OBS.Mark(13);			REPEAT OBS.Get(sym) UNTIL sym >= lparen		END ;		IF sym = ident THEN			qualident(x); selector(x);			IF x.mode = SProc THEN StandProcCall(x)			ELSIF sym = lparen THEN				OBS.Get(sym); OBH.PrepCall(x, fpar);				OBC.SaveRegisters(gR, fR, x); ActualParameters(x, fpar);				OBH.Call(x); OBC.RestoreRegisters(gR, fR, x); CheckSym(rparen)			END		ELSIF sym = number THEN			OBS.Get(sym); x.mode := Con;			CASE OBS.numtyp OF				1: x.typ := OBT.chartyp; x.a0 := OBS.intval			| 2: x.a0 := OBS.intval; OBE.SetIntType(x)			| 3: x.typ := OBT.realtyp; SYSTEM.PUT(SYSTEM.ADR(x.a0), OBS.realval)			| 4: x.typ := OBT.lrltyp; SYSTEM.PUT(SYSTEM.ADR(x.a0), OBS.lrlval)			END		ELSIF sym = string THEN			x.typ := OBT.stringtyp; x.mode := Con;			OBC.AllocString(OBS.name, x); OBS.Get(sym)		ELSIF sym = nil THEN			OBS.Get(sym); x.typ := OBT.niltyp; x.mode := Con; x.a0 := 0		ELSIF sym = lparen THEN			OBS.Get(sym); Expression(x); CheckSym(rparen)		ELSIF sym = lbrak THEN			OBS.Get(sym); OBS.Mark(29); Expression(x); CheckSym(rparen)		ELSIF sym = lbrace THEN OBS.Get(sym); Sets(x)		ELSIF sym = not THEN			OBS.Get(sym); Factor(x); OBE.MOp(not, x)		ELSE OBS.Mark(13); OBS.Get(sym); x.typ := OBT.undftyp; x.mode := Var; x.a0 := 0		END	END Factor;	PROCEDURE Term(VAR x: OBT.Item);		VAR y: OBT.Item; mulop: INTEGER;	BEGIN Factor(x);		WHILE (times <= sym) & (sym <= and) DO			mulop := sym; OBS.Get(sym);			IF mulop = and THEN OBE.MOp(and, x) END ;			Factor(y); OBE.Op(mulop, x, y)		END	END Term;	PROCEDURE SimpleExpression(VAR x: OBT.Item);		VAR y: OBT.Item; addop: INTEGER;	BEGIN		IF sym = minus THEN OBS.Get(sym); Term(x); OBE.MOp(minus, x)		ELSIF sym = plus THEN OBS.Get(sym); Term(x); OBE.MOp(plus, x)		ELSE Term(x)		END ;		WHILE (plus <= sym) & (sym <= or) DO			addop := sym; OBS.Get(sym);			IF addop = or THEN OBE.MOp(or, x) END ;			Term(y); OBE.Op(addop, x, y)		END	END SimpleExpression;	PROCEDURE Expression(VAR x: OBT.Item);		VAR y: OBT.Item; relation: INTEGER;	BEGIN SimpleExpression(x);		IF (eql <= sym) & (sym <= geq) THEN			relation := sym; OBS.Get(sym);			IF x.typ.form = Bool THEN OBE.MOp(relation, x) END ;			SimpleExpression(y); OBE.Op(relation, x, y)		ELSIF sym = in THEN			OBS.Get(sym); SimpleExpression(y); OBE.In(x, y)		ELSIF sym = is THEN			IF x.mode >= Typ THEN OBS.Mark(112) END ;			OBS.Get(sym);			IF sym = ident THEN				qualident(y);				IF y.mode = Typ THEN OBE.TypTest(x, y, TRUE) ELSE OBS.Mark(52) END			ELSE OBS.Mark(10)			END		END	END Expression;	PROCEDURE ProcedureDeclaration;		VAR proc, proc1, par: OBT.Object;			L1: INTEGER;			mode: SHORTINT; body: BOOLEAN;			psize, dsize: LONGINT;	BEGIN dsize := 0; proc := NIL; body := TRUE;		IF (sym # ident) & (OBC.level = 0) THEN			IF sym = times THEN mode := LProc; OBS.Mark(10)			ELSIF sym = arrow THEN (*forward*) mode := LProc; body := FALSE			ELSIF sym = plus THEN mode := IProc			ELSIF sym = minus THEN mode := CProc; body := FALSE			ELSE mode := LProc; OBS.Mark(10)			END ;			OBS.Get(sym)		ELSE mode := LProc		END ;		IF sym = ident THEN			IF OBC.level = 0 THEN OBT.Find(proc1, L1) ELSE proc1 := NIL END;			IF (proc1 # NIL) & (proc1.mode = LProc) & (proc1.a0 = 0) THEN				(*there exists a corresponding forward declaration*)				OBT.Remove(proc1); OBT.Insert(OBS.name, proc);				CheckMark(proc.marked); mode := LProc; OBC.FixLink(proc1.a1)			ELSE				IF proc1 # NIL THEN OBS.Mark(1); proc1 := NIL END ;				OBT.Insert(OBS.name, proc); CheckMark(proc.marked)			END ;			proc.mode := mode; proc.typ := OBT.notyp; proc.a0 := 0; proc.a1 := 0; proc.dsc := NIL;			INC(OBC.level); OBT.OpenScope(OBC.level);			IF (mode = LProc) & (OBC.level = 1) THEN psize := LParOrg ELSE psize := XParOrg END ;			IF sym = lparen THEN				OBS.Get(sym); FormalParameters(proc.typ, psize); proc.dsc := OBT.topScope.next			END ;			IF proc1 # NIL THEN  (*forward*)				OBH.CompareParLists(proc.dsc, proc1.dsc);				IF proc.typ # proc1.typ THEN OBS.Mark(118) END			END ;			IF mode = CProc THEN				IF sym = number THEN proc.a0 := OBS.intval; OBS.Get(sym) ELSE OBS.Mark(17) END			END ;			IF body THEN				CheckSym(semicolon); proc.a0 := OBC.pc; OBT.topScope.typ := proc.typ;				OBT.topScope.a1 := mode*10000H + psize; (*for RETURN statements*)				OBH.Enter(mode, L1); par := proc.dsc;				WHILE par # NIL DO					(*code for dynamic array value parameters*)					IF (par.typ.form = DynArr) & (par.mode = Var) THEN						OBH.CopyDynArray(par.a0, par.typ)					END ;					par := par.next				END ;				Block(dsize); proc.dsc := OBT.topScope.next;				IF proc.typ = OBT.notyp THEN OBH.Return(proc.mode, psize) ELSE OBH.Trap(17) END ;				IF OBE.inxloc > 0 THEN OBC.FixLink(OBE.inxloc); OBC.PutF1(0F2H); OBC.PutByte(15) END ;				IF OBE.tchkloc > 0 THEN OBC.FixLink(OBE.tchkloc); OBC.PutF1(0F2H); OBC.PutByte(17) END ;				IF dsize >= LDataSize THEN OBS.Mark(209); dsize := 0 END ;				IF OBH.clrchk & (dsize < 4) THEN dsize := 4 END ;				OBC.FixupWith(L1, dsize); proc.a2 := OBC.pc;				IF sym = ident THEN					IF OBS.name # proc.name THEN OBS.Mark(4) END ;					OBS.Get(sym)				ELSE OBS.Mark(10)				END			END ;			DEC(OBC.level); OBT.CloseScope		END	END ProcedureDeclaration;	PROCEDURE CaseLabelList(LabelForm: INTEGER;						VAR n: INTEGER; VAR tab: ARRAY OF OBH.LabelRange);		VAR x, y: OBT.Item; i, f: INTEGER;	BEGIN		IF ~(LabelForm IN labeltyps) THEN OBS.Mark(61) END ;		LOOP ConstExpression(x); f := x.typ.form;			IF f IN intSet THEN				IF LabelForm < f THEN OBS.Mark(60) END			ELSIF f # LabelForm THEN OBS.Mark(60)			END ;			IF sym = upto THEN				OBS.Get(sym); ConstExpression(y);				IF (y.typ.form # f) & ~((f IN intSet) & (y.typ.form IN intSet)) THEN OBS.Mark(60) END ;				IF y.a0 < x.a0 THEN OBS.Mark(63); y.a0 := x.a0 END			ELSE y := x			END ;			(*enter label range into ordered table*)  i := n;			IF i < NofCases THEN				LOOP					IF i = 0 THEN EXIT END ;					IF tab[i-1].low <= y.a0 THEN						IF tab[i-1].high >= x.a0 THEN OBS.Mark(62) END ;						EXIT					END ;					tab[i] := tab[i-1]; DEC(i)				END ;				tab[i].low := SHORT(x.a0); tab[i].high := SHORT(y.a0);				tab[i].label := OBC.pc; INC(n)			ELSE OBS.Mark(213)			END ;			IF sym = comma THEN OBS.Get(sym)			ELSIF (sym = number) OR (sym = ident) THEN OBS.Mark(19)			ELSE EXIT			END		END	END CaseLabelList;	PROCEDURE StatSeq;		VAR fpar: OBT.Object; xtyp: OBT.Struct;				x, x0, y, z: OBT.Item; L0, L1, ExitIndex: INTEGER;		PROCEDURE CasePart;			VAR x: OBT.Item; n, L0, L1, L2, L3: INTEGER;					tab: ARRAY NofCases OF OBH.LabelRange;		BEGIN n := 0; L3 := 0;			Expression(x); OBH.CaseIn(x, L0, L1); OBC.FreeRegs({});			CheckSym(of);			LOOP				IF sym < bar THEN					CaseLabelList(x.typ.form, n, tab);					CheckSym(colon); StatSeq; OBH.FJ(L3)				END ;				IF sym = bar THEN OBS.Get(sym) ELSE EXIT END			END ;			L2 := OBC.pc;			IF sym = else THEN OBS.Get(sym); StatSeq; OBH.FJ(L3)			ELSE OBH.Trap(16)			END ;			OBH.CaseOut(L0, L1, L2, L3, n, tab)		END CasePart;	BEGIN		LOOP			IF sym < ident THEN OBS.Mark(14);				REPEAT OBS.Get(sym) UNTIL sym >= ident			END ;			IF sym = ident THEN				qualident(x); selector(x);				IF sym = becomes THEN					OBS.Get(sym); Expression(y); OBH.Assign(x, y, FALSE)				ELSIF sym = eql THEN					OBS.Mark(33); OBS.Get(sym); Expression(y); OBH.Assign(x, y, FALSE)				ELSIF x.mode = SProc THEN					StandProcCall(x);					IF x.typ.form # NoTyp THEN OBS.Mark(55) END				ELSE OBH.PrepCall(x, fpar);					IF sym = lparen THEN						OBS.Get(sym); ActualParameters(x, fpar); CheckSym(rparen)					ELSIF IsParam(fpar) THEN OBS.Mark(65)					END ;					OBH.Call(x);					IF x.typ.form # NoTyp THEN OBS.Mark(55) END				END			ELSIF sym = if THEN				OBS.Get(sym); Expression(x); OBH.CFJ(x, L0); OBC.FreeRegs({});				CheckSym(then); StatSeq; L1 := 0;				WHILE sym = elsif DO					OBS.Get(sym); OBH.FJ(L1); OBC.FixLink(L0);					Expression(x); OBH.CFJ(x, L0); OBC.FreeRegs({});					CheckSym(then); StatSeq				END ;				IF sym = else THEN					OBS.Get(sym); OBH.FJ(L1); OBC.FixLink(L0); StatSeq				ELSE OBC.FixLink(L0)				END ;				OBC.FixLink(L1); CheckSym(end)			ELSIF sym = case THEN				OBS.Get(sym); CasePart; CheckSym(end)			ELSIF sym = while THEN				OBS.Get(sym); L1 := OBC.pc;				Expression(x); OBH.CFJ(x, L0); OBC.FreeRegs({});				CheckSym(do); StatSeq; OBH.BJ(L1); OBC.FixLink(L0);				CheckSym(end)			ELSIF sym = repeat THEN				OBS.Get(sym); L0 := OBC.pc; StatSeq;				IF sym = until THEN					OBS.Get(sym); Expression(x); OBH.CBJ(x, L0)				ELSE OBS.Mark(43)				END			ELSIF sym = loop THEN				OBS.Get(sym); ExitIndex := ExitNo; INC(LoopLevel);				L0 := OBC.pc; StatSeq; OBH.BJ(L0); DEC(LoopLevel);				WHILE ExitNo > ExitIndex DO					DEC(ExitNo); OBC.fixup(LoopExit[ExitNo])				END ;				CheckSym(end)			ELSIF sym = for THEN				OBS.Get(sym);				IF sym = ident THEN					qualident(x);					IF ~(x.typ.form IN {SInt, Int, LInt}) THEN OBS.Mark(91) END ;					IF sym = becomes THEN						OBS.Get(sym); Expression(y); OBH.Assign(x, y, FALSE);						CheckSym(to); Expression(y);						IF y.mode # Con THEN (*temp var for limit*)							z.mode := Stk; z.typ := x.typ; OBH.Assign(z, y, TRUE); y.mode := Stk0						END ;						IF sym = by THEN OBS.Get(sym); ConstExpression(z)						ELSE z.mode := Con; z.a0 := 1						END ;						L0 := OBC.pc; x0 := x; z.typ := x.typ;						IF z.a0 > 0 THEN OBE.Op(leq, x0, y)						ELSIF z.a0 < 0 THEN OBE.Op(geq, x0, y)						ELSE OBS.Mark(99)						END ;						OBH.CFJ(x0, L1);						CheckSym(do); StatSeq; CheckSym(end);						OBE.Inc(x, z); OBH.BJ(L0); OBC.FixLink(L1);						IF y.mode = Stk0 THEN OBH.AdjustSP(-AdrSize) END					ELSE OBS.Mark(33)					END				ELSE OBS.Mark(10)				END			ELSIF sym = with THEN				OBS.Get(sym); x.obj := NIL; xtyp := NIL;				IF sym = ident THEN					qualident(x); CheckSym(colon);					IF sym = ident THEN qualident(y);						IF y.mode = Typ THEN							IF x.obj # NIL THEN								xtyp := x.typ; OBE.TypTest(x, y, FALSE); x.obj.typ := x.typ							ELSE OBS.Mark(130)							END						ELSE OBS.Mark(52)						END					ELSE OBS.Mark(10)					END				ELSE OBS.Mark(10)				END ;				CheckSym(do); OBC.FreeRegs({}); StatSeq; CheckSym(end);				IF xtyp # NIL THEN x.obj.typ := xtyp END			ELSIF sym = exit THEN				OBS.Get(sym); OBH.FJ(L0);				IF LoopLevel = 0 THEN OBS.Mark(45)				ELSIF ExitNo < 16 THEN LoopExit[ExitNo] := L0; INC(ExitNo)				ELSE OBS.Mark(214)				END			ELSIF sym = return THEN OBS.Get(sym);				IF OBC.level > 0 THEN					IF sym < semicolon THEN						Expression(x); OBH.Result(x, OBT.topScope.typ)					ELSIF OBT.topScope.typ.form # NoTyp THEN OBS.Mark(124)					END ;					OBH.Return(SHORT(OBT.topScope.a1 DIV 10000H), SHORT(OBT.topScope.a1))				ELSE (*return from module body*)					IF sym < semicolon THEN Expression(x); OBS.Mark(124) END ;					OBH.Return(LProc, LParOrg)				END			END ;			OBC.FreeRegs({});			IF sym = semicolon THEN OBS.Get(sym)			ELSIF (sym <= ident) OR (if <= sym) & (sym <= return) THEN OBS.Mark(38)			ELSE EXIT			END		END	END StatSeq;	PROCEDURE Block(VAR dsize: LONGINT);		VAR typ, forward: OBT.Struct;			obj, first: OBT.Object;			x: OBT.Item;			L0: INTEGER;			size: LONGINT;			mk: BOOLEAN;			id0: ARRAY 32 OF CHAR;	BEGIN obj := OBT.topScope;		WHILE obj.next # NIL DO obj := obj.next END ;		LOOP			IF sym = const THEN				OBS.Get(sym);				WHILE sym = ident DO					COPY(OBS.name, id0); CheckMark(mk);					IF sym = eql THEN OBS.Get(sym); ConstExpression(x)					ELSIF sym = becomes THEN OBS.Mark(9); OBS.Get(sym); ConstExpression(x)					ELSE OBS.Mark(9)					END ;					OBT.Insert(id0, obj); obj.mode := Con;					obj.typ := x.typ; obj.a0 := x.a0; obj.a1 := x.a1; obj.marked := mk;					CheckSym(semicolon)				END			END ;			IF sym = type THEN				OBS.Get(sym);				WHILE sym = ident DO					typ := OBT.undftyp; OBT.InsertType(OBS.name, obj); forward := obj.typ;											obj.mode := Typ; obj.typ := OBT.notyp; CheckMark(obj.marked);					IF sym = eql THEN OBS.Get(sym); Type(typ)					ELSIF (sym = becomes) OR (sym = colon) THEN OBS.Mark(9); OBS.Get(sym); Type(typ)					ELSE OBS.Mark(9)					END ;					obj.typ := typ;					IF typ.strobj = NIL THEN typ.strobj := obj END ;					IF forward # NIL THEN (*fixup*) SetPtrBase(forward, typ) END ;					CheckSym(semicolon)				END			END ;			IF sym = var THEN				OBS.Get(sym);				WHILE sym = ident DO					OBT.Insert(OBS.name, obj); first := obj; CheckMark(obj.marked);					obj.mode := Var; obj.typ := OBT.undftyp;					LOOP						IF sym = comma THEN OBS.Get(sym)						ELSIF sym = ident THEN OBS.Mark(19)						ELSE EXIT						END ;						IF sym = ident THEN							OBT.Insert(OBS.name, obj); CheckMark(obj.marked);							obj.mode := Var; obj.typ := OBT.undftyp						ELSE OBS.Mark(10)						END					END ;					CheckSym(colon); Type(typ); size := typ.size;					IF size >= 4 THEN INC(dsize, (-dsize) MOD 4)					ELSIF size = 2 THEN INC(dsize, dsize MOD 2)					END ;					WHILE first # NIL DO						first.typ := typ; INC(dsize, size); first.a0 := -dsize; first := first.next					END ;					CheckSym(semicolon)				END			END ;			IF (sym < const) OR (sym > var) THEN EXIT END ;		END ;		CheckUndefPointerTypes; INC(dsize, (-dsize) MOD 4);		IF OBC.level = 0 THEN OBH.LFJ(L0); OBC.SetStrOffset(dsize) ELSE OBH.FJ(L0) END ;		WHILE sym = procedure DO			OBS.Get(sym); ProcedureDeclaration; CheckSym(semicolon)		END ;		IF OBC.level = 0 THEN OBC.fixupL(L0) ELSE OBC.fixupC(L0) END ;		OBE.inxloc := 0; OBE.tchkloc := 0;		IF sym = begin THEN OBS.Get(sym); StatSeq END ;		CheckSym(end)	END Block;	PROCEDURE CompilationUnit(source: Texts.Text; pos: LONGINT);		VAR L0: INTEGER; ch: CHAR;				time, date, key: LONGINT;				modid, impid, FName: ARRAY 32 OF CHAR;		PROCEDURE MakeFileName(VAR name, FName: ARRAY OF CHAR; ext: ARRAY OF CHAR);			VAR i, j: INTEGER; ch: CHAR;		BEGIN i := 0;			LOOP ch := name[i];				IF ch = 0X THEN EXIT END ;				FName[i] := ch; INC(i)			END ;			j := 0;			REPEAT ch := ext[j]; FName[i] := ch; INC(i); INC(j)			UNTIL ch = 0X		END MakeFileName;	BEGIN dsize := 0; LoopLevel := 0; ExitNo := 0;		OBC.Init; OBT.Init; OBS.Init(source, pos); OBS.Get(sym);		Texts.WriteString(W, "  compiling ");		IF sym = module THEN OBS.Get(sym) ELSE OBS.Mark(16) END ;		IF sym = ident THEN			Texts.WriteString(W, OBS.name); Texts.Append(Oberon.Log, W.buf);			L0 := 0; ch := OBS.name[0];			WHILE (ch # 0X) & (L0 < ModNameLen-1) DO modid[L0] := ch; INC(L0); ch := OBS.name[L0] END ;			modid[L0] := 0X;			IF ch # 0X THEN OBS.Mark(228) END ;			OBT.OpenScope(0); OBS.Get(sym);			CheckSym(semicolon); OBH.Enter(Mod, L0);			IF sym = import THEN				OBS.Get(sym);				LOOP					IF sym = ident THEN						COPY(OBS.name, impid); OBS.Get(sym);						MakeFileName(impid, FName, ".sym");						IF sym = becomes THEN OBS.Get(sym);							IF sym = ident THEN								MakeFileName(OBS.name, FName, ".sym"); OBS.Get(sym)							ELSE OBS.Mark(10)							END						END ;						OBT.Import(impid, modid, FName)					ELSE OBS.Mark(10)					END ;					IF sym = comma THEN OBS.Get(sym)					ELSIF sym = ident THEN OBS.Mark(19)					ELSE EXIT					END				END ;				CheckSym(semicolon)			END ;			IF ~OBS.scanerr THEN				Block(dsize); OBH.Return(LProc, 8);				IF OBE.inxloc > 0 THEN OBC.FixLink(OBE.inxloc); OBC.PutF1(0F2H); OBC.PutByte(15) END ;				IF OBE.tchkloc > 0 THEN OBC.FixLink(OBE.tchkloc); OBC.PutF1(0F2H); OBC.PutByte(17) END ;				IF sym = ident THEN					IF OBS.name # modid THEN OBS.Mark(4) END ;					OBS.Get(sym)				ELSE OBS.Mark(10)				END ;				IF sym # period THEN OBS.Mark(18) END ;				IF ~OBS.scanerr THEN					Oberon.GetClock(time, date); key := (date MOD 4000H) * 20000H + time;					MakeFileName(modid, FName, ".sym");					OBT.Export(modid, FName, newSF, key);					IF newSF THEN Texts.WriteString(W, " new symbol file") END ;					IF ~OBS.scanerr THEN						MakeFileName(modid, FName, ".obj");						OBC.OutCode(FName, modid, key, dsize);						Texts.WriteInt(W, OBC.pc, 6); Texts.WriteInt(W, dsize, 6)					END				END			END ;			OBT.CloseScope		ELSE OBS.Mark(10)		END;		OBT.Close;		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)	END CompilationUnit;	PROCEDURE Compile*;		VAR beg, end, time: LONGINT;			T: Texts.Text;			S: Texts.Scanner;			v: Viewers.Viewer;		PROCEDURE Options;			VAR ch: CHAR;		BEGIN			IF S.nextCh = "/" THEN				LOOP Texts.Read(S, ch);					IF ch = "x" THEN OBE.inxchk := FALSE					ELSIF ch = "t" THEN OBC.typchk := FALSE					ELSIF ch = "c" THEN OBH.clrchk := TRUE					ELSIF ch = "k" THEN OBH.stkchk := TRUE					ELSIF ch = "s" THEN newSF := TRUE					ELSE S.nextCh := ch; EXIT					END				END			END		END Options;	BEGIN OBE.inxchk := TRUE; OBC.typchk := TRUE; OBH.clrchk := FALSE;		OBH.stkchk := FALSE; newSF := FALSE;		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);		IF S.class = Texts.Char THEN			IF S.c = "*" THEN				v := Oberon.MarkedViewer();				IF (v.dsc # NIL) & (v.dsc.next IS TextFrames.Frame) THEN					Options; CompilationUnit(v.dsc.next(TextFrames.Frame).text, 0)				END			ELSIF S.c = "^" THEN				Oberon.GetSelection(T, beg, end, time);				IF time >= 0 THEN					Texts.OpenScanner(S, T, beg); Texts.Scan(S);					IF S.class = Texts.Name THEN						Options; Texts.WriteString(W, S.s); NEW(T); Texts.Open(T, S.s);						IF T.len # 0 THEN CompilationUnit(T, 0)						ELSE Texts.WriteString(W, " not found");							Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)						END					END				END			ELSIF S.c = "@" THEN				Oberon.GetSelection(T, beg, end, time);				IF time >= 0 THEN Options; CompilationUnit(T, beg) END			END		ELSE NEW(T);			WHILE S.class = Texts.Name DO				Options; Texts.WriteString(W, S.s); Texts.Open(T, S.s);				IF T.len # 0 THEN CompilationUnit(T, 0)				ELSE Texts.WriteString(W, " not found");					Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)				END ;				Texts.Scan(S)			END		END ;		Oberon.Collect(0)	END Compile;BEGIN Texts.OpenWriter(W);	Texts.WriteString(W, "Compiler  NW 14.12.93"); Texts.WriteLn(W);	Texts.Append(Oberon.Log, W.buf)END Compiler.