MODULE EditTools;   (** CAS/HM 3.12.93 **)    IMPORT        Files, Fonts, Modules, Texts, Viewers, Oberon, MenuViewers, TextFrames, ParcElems, Display;    CONST        mm = TextFrames.mm; MonsterW = 250*mm; MonsterH = 200*mm; TAB = 9X; CR = 0DX;        elem = 0; fnt = 1; col = 2; voff = 3;        OptionChar = "/";    TYPE        Node = POINTER TO NodeDesc;        NodeDesc = RECORD            l, r: Node;            mod: ARRAY 32 OF CHAR;            fnt: Fonts.Font;            col, voff: SHORTINT        END;    VAR        W, WR: Texts.Writer;        lastTime: LONGINT;        search: RECORD            set: SET;            node: Node        END;    (* output primitives *)    PROCEDURE Ch (ch: CHAR);    BEGIN Texts.Write(W, ch)    END Ch;    PROCEDURE Str (s: ARRAY OF CHAR);    BEGIN Texts.WriteString(W, s)    END Str;    PROCEDURE Int (n: LONGINT);    BEGIN Ch(" "); Texts.WriteInt(W, n, 0)    END Int;    PROCEDURE Ln;    BEGIN Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)    END Ln;    PROCEDURE Plural (n: LONGINT; s: ARRAY OF CHAR);    BEGIN Int(n); Ch(" "); Str(s);        IF n # 1 THEN Ch("s") END    END Plural;    (* generic frame primitives *)    PROCEDURE Unmark (f: TextFrames.Frame);        VAR m: Oberon.ControlMsg;    BEGIN Oberon.RemoveMarks(f.X, f.Y, f.W, f.H); m.id := Oberon.neutralize; f.handle(f, m)    END Unmark;    PROCEDURE Show (f: TextFrames.Frame; pos: LONGINT);        VAR F: TextFrames.Frame; beg, end, delta: LONGINT;    BEGIN delta := 200; Unmark(f);        LOOP beg := f.org; end := TextFrames.Pos(f, f.X + f.W, f.Y);            IF (beg <= pos) & (pos < end) OR (delta = 0) THEN EXIT END;            TextFrames.Show(f, pos - delta); delta := delta DIV 2        END    END Show;    (* argument primitives *)    PROCEDURE HoldsTF (V: Viewers.Viewer): BOOLEAN;    BEGIN        RETURN (V IS MenuViewers.Viewer) & (V.dsc.next IS TextFrames.Frame)    END HoldsTF;    PROCEDURE MarkedFrame (): TextFrames.Frame;        VAR V: Viewers.Viewer;    BEGIN V := Oberon.MarkedViewer();        IF HoldsTF(V) THEN RETURN V.dsc.next(TextFrames.Frame) ELSE RETURN NIL END    END MarkedFrame;    PROCEDURE FocusFrame (): TextFrames.Frame;        VAR V: Viewers.Viewer;    BEGIN V := Oberon.FocusViewer;        IF HoldsTF(V) THEN RETURN V.dsc.next(TextFrames.Frame) ELSE RETURN NIL END    END FocusFrame;    PROCEDURE GetMainArg (VAR S: Texts.Scanner; VAR beg, end: LONGINT);        VAR text: Texts.Text; sbeg, send, time: LONGINT;    BEGIN beg := Oberon.Par.pos; end := Oberon.Par.text.len;        Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.class = Texts.Char) & (S.line = 0) & (S.c = "^") THEN Oberon.GetSelection(text, sbeg, send, time);            IF time >= 0 THEN beg := sbeg; end := send; Texts.OpenScanner(S, text, beg); Texts.Scan(S) END        END    END GetMainArg;    PROCEDURE SkipArrow (VAR S: Texts.Scanner);    BEGIN Texts.Scan(S);        IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);            IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S) ELSE S.class := Texts.Inval END        ELSE S.class := Texts.Inval         END    END SkipArrow;    (* string primitives *)    PROCEDURE SplitFontName (fn: ARRAY OF CHAR; VAR i, j, size: INTEGER);        VAR k: INTEGER;    BEGIN i := 0; size := 0;        WHILE (fn[i] # 0X) & ((fn[i] < "0") OR ("9" < fn[i])) DO INC(i) END;        j := i; WHILE ("0" <= fn[j]) & (fn[j] <= "9") DO INC(j) END;        k := i; WHILE k < j DO size := size * 10 + ORD(fn[k]) - 30H; INC(k) END    END SplitFontName;    PROCEDURE CombineFontName (prefix, suffix: ARRAY OF CHAR; i, j, size: INTEGER; VAR fn: ARRAY OF CHAR);        VAR k: INTEGER; ch: CHAR; dig: ARRAY 10 OF CHAR;    BEGIN COPY(prefix, fn); k := 0;        REPEAT dig[k] := CHR(size MOD 10 + 30H); size := size DIV 10; INC(k) UNTIL size = 0;        REPEAT DEC(k); fn[i] := dig[k]; INC(i) UNTIL k = 0;        REPEAT ch := suffix[j]; fn[i] := ch; INC(i); INC(j) UNTIL ch = 0X    END CombineFontName;    PROCEDURE ReadName (t: Texts.Text; pos: LONGINT; VAR name: ARRAY OF CHAR);  (*ww 21 Aug 91/mh 6 Nov 92*)        VAR i: INTEGER; r: Texts.Reader; ch: CHAR;    BEGIN Texts.OpenReader(r, t, pos); i := 0;        REPEAT Texts.Read(r, ch) UNTIL (ch > " ") OR (ch = 0AX) OR (ch = 0DX);        IF ~r.eot & (ch = 22X) THEN HALT(99); Texts.Read(r, ch) END;        WHILE ~r.eot & (ch > " ") DO name[i] := ch; Texts.Read(r, ch); INC(i) END;        IF (i > 0) & (name[i-1] = 22X) THEN DEC(i) END;        name[i] := 0X    END ReadName;    (* attribute extraction / searching *)    PROCEDURE SetNode (n: Node; VAR R: Texts.Reader);        VAR msg: Texts.IdentifyMsg;    BEGIN n.fnt := R.fnt; n.col := R.col; n.voff := R.voff;        IF R.elem # NIL THEN R.elem.handle(R.elem, msg); COPY(msg.mod, n.mod)        ELSE n.mod[0] := 0X        END    END SetNode;    PROCEDURE Less (x, y: Node): BOOLEAN;    BEGIN        IF x.mod < y.mod THEN RETURN TRUE        ELSIF x.mod = y.mod THEN            IF x.fnt.name < y.fnt.name THEN RETURN TRUE            ELSIF x.fnt.name = y.fnt.name THEN                IF x.col < y.col THEN RETURN TRUE                ELSIF x.col = y.col THEN                    IF x.voff < y.voff THEN RETURN TRUE END                END            END        END;        RETURN FALSE    END Less;    PROCEDURE Insert (t, x: Node);        VAR p, c: Node;    BEGIN p := t; c := NIL;        WHILE t # NIL DO p := t;            IF Less(x, t) THEN t := t.l ELSE c := t; t := t.r END        END;        IF (c = NIL) OR Less(c, x) THEN            IF Less(x, p) THEN NEW(p.l); c := p.l ELSE NEW(p.r); c := p.r END;            c^ := x^        END    END Insert;    PROCEDURE List (t: Node);    BEGIN        IF t # NIL THEN            List(t.l);            Ln;            IF t.mod[0] # 0X THEN Str("  elem "); Str(t.mod) END;            Str("  font "); Str(t.fnt.name); Str("  col"); Int(t.col); Str("  off"); Int(t.voff);            List(t.r)        END    END List;    PROCEDURE ScanText (text: Texts.Text; beg, end: LONGINT);        VAR tree, cand: Node; R: Texts.Reader; pos: LONGINT; ch0, ch: CHAR;    BEGIN  pos := beg;        Texts.OpenReader(R, text, beg); Texts.Read(R, ch0); INC(pos);        IF pos > end THEN Str("  end of text")        ELSE NEW(tree); SetNode(tree, R); tree.l := NIL; tree.r := NIL;            IF pos = end THEN List(tree); Str(" ascii"); Int(ORD(ch0))            ELSE Texts.Read(R, ch); INC(pos);                NEW(cand); cand.l := NIL; cand.r := NIL;                WHILE pos <= end DO SetNode(cand, R); Insert(tree, cand);                    Texts.Read(R, ch); INC(pos)                END;                List(tree)            END        END;        Ln    END ScanText;    PROCEDURE Scan (VAR S: Texts.Scanner; beg, end: LONGINT; n: Node; VAR set: SET);    BEGIN set := {};        WHILE (beg < end) & (S.line = 0) & (S.class = Texts.Name) DO beg := Texts.Pos(S);            IF S.s = "elem" THEN Texts.Scan(S);                IF (S.line = 0) & (S.class = Texts.Name) THEN                    INCL(set, elem); COPY(S.s, n.mod); Texts.Scan(S)                END            ELSIF S.s = "font" THEN Texts.Scan(S);                IF (S.line = 0) & (S.class = Texts.Name) THEN n.fnt := Fonts.This(S.s);                    IF n.fnt.name = S.s THEN INCL(set, fnt); Texts.Scan(S) END                END            ELSIF S.s = "col" THEN Texts.Scan(S);                IF (S.line = 0) & (S.class = Texts.Int) & (-128 <= S.i) & (S.i <= 127) THEN                    INCL(set, col); n.col := SHORT(SHORT(S.i)); Texts.Scan(S)                END            ELSIF S.s = "off" THEN Texts.Scan(S);                IF (S.line = 0) & (S.class = Texts.Int) & (-128 <= S.i) & (S.i <= 127) THEN                    INCL(set, voff); n.voff := SHORT(SHORT(S.i)); Texts.Scan(S)                END            ELSE beg := end            END        END    END Scan;    PROCEDURE Equal (x, y: Node; set: SET): BOOLEAN;    BEGIN        IF (elem IN set) & (x.mod # y.mod) THEN RETURN FALSE END;        IF (fnt IN set) & (x.fnt # y.fnt) THEN RETURN FALSE END;        IF (col IN set) & (x.col # y.col) THEN RETURN FALSE END;        RETURN ~(voff IN set) OR (x.voff = y.voff)    END Equal;    (** text manipulation **)    PROCEDURE IncFontSize* (T: Texts.Text; beg, end: LONGINT; delta: INTEGER);        VAR R: Texts.Reader; fnt: Fonts.Font; fn: Fonts.Name; org: LONGINT; i, j, size: INTEGER; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE ~R.eot & (beg < end) DO org := beg; fnt := R.fnt;            WHILE ~R.eot & (beg < end) & (R.fnt = fnt) DO INC(beg); Texts.Read(R, ch) END;            SplitFontName(fnt.name, i, j, size);            IF i < j THEN CombineFontName(fnt.name, fnt.name, i, j, size + delta, fn); fnt := Fonts.This(fn);                IF fnt.name = fn THEN Texts.ChangeLooks(T, org, beg, {0}, fnt, 0, 0) END            END        END    END IncFontSize;    PROCEDURE ChangeFontSize* (T: Texts.Text; beg, end: LONGINT; old, new: INTEGER);        VAR R: Texts.Reader; fnt: Fonts.Font; fn: Fonts.Name; org: LONGINT; i, j, size: INTEGER; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE ~R.eot & (beg < end) DO org := beg; fnt := R.fnt;            WHILE ~R.eot & (beg < end) & (R.fnt = fnt) DO INC(beg); Texts.Read(R, ch) END;            SplitFontName(fnt.name, i, j, size);            IF (i < j) & ((size = old) OR (old = -1)) THEN                CombineFontName(fnt.name, fnt.name, i, j, new, fn); fnt := Fonts.This(fn);                IF fnt.name = fn THEN Texts.ChangeLooks(T, org, beg, {0}, fnt, 0, 0) END            END        END    END ChangeFontSize;    PROCEDURE ChangeFontFamily* (T: Texts.Text; beg, end: LONGINT; old, new: ARRAY OF CHAR);        VAR R: Texts.Reader; fnt: Fonts.Font; fn: Fonts.Name; org: LONGINT; i, i1, j, j1, size, size1: INTEGER; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE ~R.eot & (beg < end) DO org := beg; fnt := R.fnt;            WHILE ~R.eot & (beg < end) & (R.fnt = fnt) DO INC(beg); Texts.Read(R, ch) END;            SplitFontName(fnt.name, i, j, size); COPY(fnt.name, fn); fn[i] := 0X;            IF (i < j) & ((fn = old) OR (old[0] = "?")) THEN SplitFontName(new, i1, j1, size1);                CombineFontName(new, fnt.name, i1, j, size, fn); fnt := Fonts.This(fn);                IF fnt.name = fn THEN Texts.ChangeLooks(T, org, beg, {0}, fnt, 0, 0) END            END        END    END ChangeFontFamily;    PROCEDURE ChangeFontStyle* (T: Texts.Text; beg, end: LONGINT; old, new: CHAR);        VAR R: Texts.Reader; fnt: Fonts.Font; fn: Fonts.Name; org: LONGINT; i, j, k, size: INTEGER; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE ~R.eot & (beg < end) DO org := beg; fnt := R.fnt;            WHILE ~R.eot & (beg < end) & (R.fnt = fnt) DO INC(beg); Texts.Read(R, ch) END;            SplitFontName(fnt.name, i, j, size);            IF (i < j) & ((fnt.name[j] = old) OR (old = "?")) & (fnt.name[j] # new) THEN COPY(fnt.name, fn);                IF fn[j] = "." THEN k := j+1;                    WHILE fn[k] # 0X DO INC(k) END;                    WHILE k >= j DO fn[k+1] := fn[k]; DEC(k) END                ELSIF new = "." THEN k := j;                    REPEAT fn[k] := fn[k+1]; INC(k) UNTIL fn[k] = 0X                END;                fn[j] := new; fnt := Fonts.This(fn);                IF fnt.name = fn THEN Texts.ChangeLooks(T, org, beg, {0}, fnt, 0, 0) END            END        END    END ChangeFontStyle;    PROCEDURE ChangeFont* (T: Texts.Text; beg, end: LONGINT; old, new: ARRAY OF CHAR);        VAR R: Texts.Reader; fnt: Fonts.Font; org: LONGINT; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE ~R.eot & (beg < end) DO org := beg; fnt := R.fnt;            WHILE ~R.eot & (beg < end) & (R.fnt = fnt) DO INC(beg); Texts.Read(R, ch) END;            IF fnt.name = old THEN fnt := Fonts.This(new);                IF fnt.name = new THEN Texts.ChangeLooks(T, org, beg, {0}, fnt, 0, 0) END            END        END    END ChangeFont;    PROCEDURE Count* (T: Texts.Text; beg, end: LONGINT; VAR wc, pc, ec: LONGINT);        VAR R: Texts.Reader; ch: CHAR;    BEGIN wc := 0; pc := 0; ec := 0;        Texts.OpenReader(R, T, beg); Texts.Read(R, ch); INC(beg);        WHILE beg <= end DO            WHILE (beg <= end) & (ch <= " ") DO                IF R.elem # NIL THEN INC(ec)                ELSIF ch = CR THEN INC(pc)                END;                Texts.Read(R, ch); INC(beg)            END;            IF beg <= end THEN INC(wc);                WHILE (beg <= end) & (ch > " ") DO Texts.Read(R, ch); INC(beg) END            END        END    END Count;    PROCEDURE DeleteMonsters* (T: Texts.Text; monsterW, monsterH: LONGINT; VAR mc: LONGINT);        VAR e: Texts.Elem; R: Texts.Reader; pos: LONGINT;            msg: TextFrames.DisplayMsg;    BEGIN Texts.OpenReader(R, T, 0); Texts.ReadElem(R); mc := 0;        WHILE R.elem # NIL DO e := R.elem;            IF ~(e IS TextFrames.Parc) THEN pos := Texts.Pos(R)-1;                msg.prepare := TRUE; msg.fnt := R.fnt; msg.col := R.col; msg.pos := pos; msg.indent := 0;                e.handle(e, msg);                IF (e.W > monsterW) OR (e.H > monsterH) THEN                    Texts.Delete(T, pos, pos + 1); INC(mc); Texts.OpenReader(R, T, pos)                END            END;            Texts.ReadElem(R)        END    END DeleteMonsters;    PROCEDURE DeleteElems* (T: Texts.Text; beg, end: LONGINT);        VAR R: Texts.Reader; ch: CHAR;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE beg < end DO            IF R.elem # NIL THEN Texts.Delete(T, beg, beg + 1); Texts.OpenReader(R, T, beg); DEC(end)            ELSE INC(beg)            END;            Texts.Read(R, ch)        END    END DeleteElems;    PROCEDURE SelectedFrame* (): TextFrames.Frame;        VAR time: LONGINT; v: Viewers.Viewer; x: INTEGER; f, F: TextFrames.Frame;    BEGIN        time := -1; x := 0; F := NIL;        WHILE x < Viewers.curW DO            v := Viewers.This(x, 0);            WHILE v.state > 1 DO                IF v.dsc.next IS TextFrames.Frame THEN                    f := v.dsc.next(TextFrames.Frame);                     IF f.hasSel & (f.time > time) THEN F := f; time := f.time END;                END;                v := Viewers.Next(v)            END;            x := x + v.W        END;        RETURN F    END SelectedFrame;    PROCEDURE ConvertToAscii* (T: Texts.Text; beg, end: LONGINT);   (* mh 27.10.92 *)        CONST doubleS = 0ABX;        VAR R: Texts.Reader; ch: CHAR;        PROCEDURE repl (by: ARRAY OF CHAR);            VAR i: LONGINT;        BEGIN i := 0;            WHILE by[i] # 0X DO INC(i) END;            Texts.Delete(T, beg, beg+1); DEC(end);            IF i > 0 THEN Texts.SetFont(WR, R.fnt); Texts.SetColor(WR, R.col); Texts.SetOffset(WR, R.voff);                Texts.WriteString(WR, by); Texts.Insert(T, beg, WR.buf); INC(beg, i); INC(end, i)            END;            Texts.OpenReader(R, T, beg)        END repl;        PROCEDURE replch (by: CHAR);    (* needed because compiler does not allow open arrays of length 1 *)        BEGIN            Texts.Delete(T, beg, beg+1); DEC(end);            Texts.SetFont(WR, R.fnt); Texts.SetColor(WR, R.col); Texts.SetOffset(WR, R.voff);            Texts.Write(WR, by); Texts.Insert(T, beg, WR.buf); INC(beg); INC(end);            Texts.OpenReader(R, T, beg)        END replch;    BEGIN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);        WHILE beg < end DO            IF ch = TAB THEN repl("  ")            ELSIF ch = "ƒ" THEN repl("ae") ELSIF ch = "„" THEN repl("oe") ELSIF ch = "…" THEN repl("ue")            ELSIF ch = "€" THEN repl("Ae") ELSIF ch = "" THEN repl("Oe") ELSIF ch = "‚" THEN repl("Ue")            ELSIF ch = doubleS THEN repl("ss")            ELSIF (ch = "”") OR (ch = "‹") OR (ch = "†") THEN replch("a")            ELSIF (ch = "") OR (ch = "Œ") OR (ch = "‡") OR (ch = "‘") THEN replch("e")            ELSIF (ch = "") OR (ch = "ˆ") OR (ch = "’") THEN replch("i")            ELSIF (ch = "Ž") OR (ch = "‰") THEN replch("o")            ELSIF (ch = "") OR (ch = "Š") THEN replch("u")            ELSIF (ch = "“") THEN replch("c")            ELSIF (ch = "•") THEN replch("n")            ELSE INC(beg)            END;            Texts.Read(R, ch)        END    END ConvertToAscii;    PROCEDURE UnmarkMenu* (V: Viewers.Viewer);        VAR R: Texts.Reader; text: Texts.Text; ch: CHAR;    BEGIN        IF (V IS MenuViewers.Viewer) & (V.dsc IS TextFrames.Frame) THEN            text := V.dsc(TextFrames.Frame).text;            IF text.len > 0 THEN Texts.OpenReader(R, text, text.len - 1); Texts.Read(R, ch);                IF ch = "!" THEN Texts.Delete(text, text.len - 1, text.len) END            END        END    END UnmarkMenu;    PROCEDURE ReadNonWhiteSp (VAR R: Texts.Reader; VAR ch: CHAR);    BEGIN        REPEAT Texts.Read(R, ch) UNTIL (ch > " ") OR R.eot;    END ReadNonWhiteSp;    (** commands **)    PROCEDURE SearchDiff*;  (** takes the two most recent selections **)        VAR f0, f1: TextFrames.Frame; R0, R1: Texts.Reader; ch0, ch1: CHAR; pos: LONGINT;            S: Texts.Scanner; whiteSp: BOOLEAN;    BEGIN        whiteSp := TRUE;        Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.line = 0) & (S.class = Texts.Char) & (S.c = OptionChar) THEN Texts.Scan(S);            IF (S.class = Texts.Name) & (CAP(S.s[0]) = "W") THEN whiteSp := FALSE END;        END;        f0 := SelectedFrame(); IF f0 # NIL THEN TextFrames.RemoveSelection(f0) END;        f1 := SelectedFrame();        IF f1 # NIL THEN            Texts.OpenReader(R0, f0.text, f0.selbeg.pos); Texts.OpenReader(R1, f1.text, f1.selbeg.pos);            IF whiteSp THEN                REPEAT Texts.Read(R0, ch0); Texts.Read(R1, ch1) UNTIL (ch0 # ch1) OR (ch0 = 0X)            ELSE                REPEAT ReadNonWhiteSp(R0, ch0); ReadNonWhiteSp(R1, ch1) UNTIL (ch0 # ch1) OR (ch0 = 0X)            END;            pos := Texts.Pos(R0)-1; Show(f0, pos); TextFrames.SetSelection(f0, pos, pos + 1);            pos := Texts.Pos(R1)-1; Show(f1, pos); TextFrames.SetSelection(f1, pos, pos + 1);        END    END SearchDiff;    PROCEDURE GetAttr*; (** ("*" | "@") **)        VAR F: TextFrames.Frame; S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.class = Texts.Char) & (S.line = 0) THEN Str("EditTools.GetAttr");            F := MarkedFrame(); Oberon.GetSelection(text, beg, end, time);            IF (S.c = "*") & (F # NIL) THEN ScanText(F.text, 0, F.text.len)            ELSIF (S.c = "@") & (time >= 0) THEN ScanText(text, beg, end)            END        END    END GetAttr;    PROCEDURE SearchAttr*;  (** selection, caret **)        VAR f: TextFrames.Frame; S: Texts.Scanner; R: Texts.Reader;            org, beg, end: LONGINT; ch: CHAR;            x, n: Node; set: SET;    BEGIN f := FocusFrame();        IF f # NIL THEN GetMainArg(S, beg, end);            NEW(n); Scan(S, beg, end, n, set);            IF (set = {}) & (search.set # {}) THEN set := search.set; n := search.node END;            IF set # {} THEN search.set := set; search.node := n;                IF f.hasCar THEN org := f.carloc.pos ELSE org := 0 END;                Texts.OpenReader(R, f.text, org); Texts.Read(R, ch);                NEW(x); SetNode(x, R);                WHILE ~R.eot & ~Equal(x, n, set) DO Texts.Read(R, ch); SetNode(x, R) END;                IF ~R.eot THEN Show(f, Texts.Pos(R)); TextFrames.SetCaret(f, Texts.Pos(R))                ELSE TextFrames.RemoveCaret(f)                END            END        END    END SearchAttr;    PROCEDURE IncSize*; (** size; selection **)        VAR S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        Oberon.GetSelection(text, beg, end, time);        IF (time >= lastTime) & (S.class = Texts.Int) & (S.line = 0) & (-1000 <= S.i) & (S.i < 1000) THEN lastTime := time;            IncFontSize(text, beg, end, SHORT(S.i))        END    END IncSize;    PROCEDURE ChangeSize*;  (** {old "=>" new}, selection **)        VAR S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT; old: INTEGER;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        Oberon.GetSelection(text, beg, end, time);        IF (time >= lastTime) & (S.line = 0) THEN            WHILE ~S.eot & ((S.class = Texts.Int) & (-1000 <= S.i) & (S.i < 1000) OR (S.class = Texts.Char) & (S.c = "?")) DO                IF (S.class = Texts.Char) & (S.c = "?") THEN old := -1 ELSE old := SHORT(S.i) END;                SkipArrow(S);                IF (S.class = Texts.Int) & (-1000 <= S.i) & (S.i < 1000) THEN lastTime := time;                    ChangeFontSize(text, beg, end, old, SHORT(S.i)); Texts.Scan(S)                END            END        END    END ChangeSize;    PROCEDURE ChangeStyle*; (** {old "=>" new}, selection **)        VAR S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT; old, new: CHAR;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        Oberon.GetSelection(text, beg, end, time);        IF (time >= lastTime) & (S.line = 0) THEN            WHILE ~S.eot & ((S.class = Texts.Name) OR (S.class = Texts.Char)) DO                IF S.class = Texts.Char THEN old := S.c ELSE old := S.s[0] END;                SkipArrow(S);                IF (S.class = Texts.Name) OR (S.class = Texts.Char) THEN lastTime := time;                    IF S.class = Texts.Char THEN new := S.c ELSE new := S.s[0] END;                    ChangeFontStyle(text, beg, end, old, new); Texts.Scan(S)                END            END        END    END ChangeStyle;    PROCEDURE ChangeFamily*;    (** {old "=>" new}, selection **)        VAR S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT; old: Fonts.Name;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        Oberon.GetSelection(text, beg, end, time);        IF (time >= lastTime) & (S.line = 0) THEN            WHILE ~S.eot & ((S.class = Texts.Name) OR (S.class = Texts.Char) & (S.c = "?")) DO                IF (S.class = Texts.Char) & (S.c = "?") THEN old[0] := "?"; old[1] := 0X ELSE COPY(S.s, old) END;                SkipArrow(S);                IF S.class = Texts.Name THEN lastTime := time;                    ChangeFontFamily(text, beg, end, old, S.s); Texts.Scan(S)                END            END        END    END ChangeFamily;    PROCEDURE Change*;  (** {old "=>" new}, selection **)        VAR S: Texts.Scanner; text: Texts.Text; beg, end, time: LONGINT; old: Fonts.Name;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        Oberon.GetSelection(text, beg, end, time);        IF (time >= lastTime) & (S.line = 0) THEN            WHILE S.class = Texts.Name DO COPY(S.s, old); SkipArrow(S);                IF S.class = Texts.Name THEN lastTime := time;                    ChangeFont(text, beg, end, old, S.s); Texts.Scan(S)                END            END        END    END Change;    PROCEDURE Words*;   (** "@" | ("^" | "*" | {name} "~") **)        VAR S: Texts.Scanner; frame: TextFrames.Frame; text: Texts.Text;            cc, ct, wc, wt, pc, pt, ec, et, beg1, end1, beg, end, time: LONGINT;    BEGIN GetMainArg(S, beg1, end1); frame := MarkedFrame(); Oberon.GetSelection(text, beg, end, time);        ct := 0; wt := 0; pt := 0; et := 0;        IF (S.class = Texts.Char) & (S.c = "*") & (frame # NIL) THEN Str("EditTools.Words  *");            cc := frame.text.len; Count(frame.text, 0, cc, wc, pc, ec);            Plural(pc, "CR"); Ch(","); Plural(wc, "word"); Ch(","); Plural(cc, "char"); Ch(","); Plural(ec, "element"); Ln        ELSIF (S.class = Texts.Char) & (S.c = "@") & (time >= 0) THEN Str("EditTools.Words  @");            cc := end - beg; Count(text, beg, end, wc, pc, ec);            Plural(pc, "CR"); Ch(","); Plural(wc, "word"); Ch(","); Plural(cc, "char"); Ch(","); Plural(ec, "element"); Ln        ELSIF S.class = Texts.Name THEN Str("EditTools.Words");            REPEAT text := TextFrames.Text(S.s);                Str("  "); Str(S.s); cc := text.len; Count(text, 0, cc, wc, pc, ec);                Plural(pc, "CR"); Ch(","); Plural(wc, "word"); Ch(","); Plural(cc, "char"); Ch(","); Plural(ec, "element"); Ln;                INC(ct, cc); INC(wt, wc); INC(pt, pc); INC(et, ec); Texts.Scan(S)            UNTIL S.eot OR (S.class # Texts.Name) OR (Texts.Pos(S) > end1);            Str("  total");            Plural(pt, "CR"); Ch(","); Plural(wt, "word"); Ch(","); Plural(ct, "char"); Ch(","); Plural(et, "element"); Ln        END    END Words;    PROCEDURE Cleanup*; (** "*" | ("^" | {name} "~") **)        VAR S: Texts.Scanner; frame: TextFrames.Frame; text: Texts.Text; mc, beg, end, len: LONGINT; res: INTEGER;    BEGIN GetMainArg(S, beg, end); frame := MarkedFrame();        IF (S.class = Texts.Char) & (S.c = "*") & (frame # NIL) THEN Str("EditTools.Cleanup  *");            DeleteMonsters(frame.text, MonsterW, MonsterH, mc);            Ch(" "); Plural(mc, "elem"); Str(" deleted"); Ln        ELSIF S.class = Texts.Name THEN Str("EditTools.Cleanup"); Ln;            REPEAT text := TextFrames.Text(S.s);                Str("  "); Str(S.s); DeleteMonsters(text, MonsterW, MonsterH, mc);                IF mc # 0 THEN Texts.Close(text, S.s) ELSE Str(" not changed") END;                Ln; Texts.Scan(S)            UNTIL S.eot OR (S.class # Texts.Name) OR (Texts.Pos(S) > end)        END    END Cleanup;    PROCEDURE Refresh*; (** "*" **)        VAR frame: TextFrames.Frame; f: Files.File; text: Texts.Text; r: Files.Rider;    BEGIN frame := MarkedFrame();        IF frame # NIL THEN Str("EditTools.Refresh"); Texts.Append(Oberon.Log, W.buf);            text := frame.text; f := Files.New("");            Files.Set(r, f, 0); Texts.Store(r, text);            Files.Set(r, f, 0); Texts.Load(r, text);            Texts.ChangeLooks(text, 0, text.len, {}, NIL, 0, 0);            Int(Files.Length(f)); Ln        END    END Refresh;    PROCEDURE RemoveElems*; (** "*" | "@" **)        VAR S: Texts.Scanner; frame: TextFrames.Frame; text: Texts.Text; beg, end, time: LONGINT;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.line = 0) & (S.class = Texts.Char) THEN            Oberon.GetSelection(text, beg, end, time); frame := MarkedFrame();            IF (S.c = "*") & (frame # NIL) THEN DeleteElems(frame.text, 0, frame.text.len)            ELSIF (S.c = "@") & (time >= lastTime) THEN lastTime := time;                DeleteElems(text, beg, end)            END        END    END RemoveElems;    PROCEDURE ToAscii*; (** "*" | "@" **)        VAR S: Texts.Scanner; frame: TextFrames.Frame; text: Texts.Text; beg, end, time: LONGINT;    BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.line = 0) & (S.class = Texts.Char) THEN            Oberon.GetSelection(text, beg, end, time); frame := MarkedFrame();            IF (S.c = "*") & (frame # NIL) THEN ConvertToAscii(frame.text, 0, frame.text.len)            ELSIF (S.c = "@") & (time >= lastTime) THEN lastTime := time;                ConvertToAscii(text, beg, end)            END        END    END ToAscii;    PROCEDURE NoNotify (text: Texts.Text; op: INTEGER; beg, end: LONGINT);    END NoNotify;    PROCEDURE InsertCR*;    (** int ( "*" | "@") **)        VAR S: Texts.Scanner; text: Texts.Text; R: Texts.Reader; oldNotify: Texts.Notifier; ch: CHAR;            beg, beg0, end, lineEnd, time: LONGINT; frame: TextFrames.Frame;                PROCEDURE GetLineEnd (pos, len: LONGINT; VAR end: LONGINT; VAR ch: CHAR);            VAR R: Texts.Reader; pos0: LONGINT;        BEGIN end := pos; pos0 := pos;            Texts.OpenReader(R, text, pos);            LOOP  (*end = pos0 or position after last read blank*)                Texts.Read(R, ch); INC(pos); DEC(len);                IF R.eot THEN end := text.len; EXIT                ELSIF ch = CR THEN end := pos; EXIT                ELSIF ch = " " THEN end := pos                ELSIF len <= 0 THEN                    IF end = pos0 THEN end := pos ELSE ch := " " END;                    EXIT                END            END        END GetLineEnd;            BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);        IF (S.class = Texts.Int) THEN Texts.Scan(S); text := NIL;            IF (S.line = 0) & (S.class = Texts.Char) THEN                IF S.c = "*" THEN frame := MarkedFrame(); text := frame.text; beg := 0; end := text.len; time := 1;                ELSIF S.c = "@" THEN Oberon.GetSelection(text, beg, end, time);                END;            END;            IF text # NIL THEN beg0 := beg; ch := " ";                oldNotify :=  text.notify; text.notify := NoNotify;                WHILE (beg > 0) & (ch # CR) DO                    DEC(beg); Texts.OpenReader(R, text, beg); Texts.Read(R, ch);                    IF ch = CR THEN INC(beg) END                END;                LOOP GetLineEnd(beg, S.i, lineEnd, ch);                    IF lineEnd >= end THEN EXIT                    ELSIF ch = CR THEN (*line already terminated by CR*)                    ELSIF ch = " " THEN (*replace blank by CR*)                        Texts.Delete(text, lineEnd - 1, lineEnd);                        Texts.WriteLn(W); Texts.Insert(text, lineEnd - 1, W.buf)                    ELSE (*the whole line is one word; break it*)                        Texts.WriteLn(W); Texts.Insert(text, lineEnd, W.buf); INC(lineEnd); INC(end)                    END;                    beg := lineEnd                END;                text.notify := oldNotify;                text.notify(text, Texts.replace, beg0, end)            END        END    END InsertCR;    PROCEDURE RemoveCR*;    (** "*" | "@" **)        VAR text: Texts.Text; R: Texts.Reader; beg, beg0, end, time: LONGINT; ch, lastCh, nextCh: CHAR;        oldNotify: Texts.Notifier; frame: TextFrames.Frame; S: Texts.Scanner;    BEGIN        Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S); text := NIL;        IF (S.line = 0) & (S.class = Texts.Char) THEN            IF S.c = "*" THEN frame := MarkedFrame(); text := frame.text; beg := 0; end := text.len; time := 1;            ELSIF S.c = "@" THEN Oberon.GetSelection(text, beg, end, time);            END        END;        IF text # NIL THEN            IF time >= 0 THEN beg0 := beg; lastCh := 0X;                oldNotify :=  text.notify; text.notify := NoNotify;                Texts.OpenReader(R, text, beg);                WHILE beg < end DO                    Texts.Read(R, ch); INC(beg);                    IF ch = CR THEN                        Texts.Read(R, nextCh);                        IF (lastCh # CR) & (nextCh # CR) THEN                            Texts.Delete(text, beg-1, beg); Texts.Write(W, " "); Texts.Insert(text, beg-1, W.buf)                        END;                        Texts.OpenReader(R, text, beg)                    END;                    lastCh := ch                END;                text.notify := oldNotify;                text.notify(text, Texts.replace, beg0, end)            END        END    END RemoveCR;    PROCEDURE ShowAliens*;        VAR F: TextFrames.Frame; R: Texts.Reader; none: BOOLEAN; identify: Texts.IdentifyMsg;    BEGIN F := MarkedFrame();        IF (F # NIL) THEN Str("EditTools.ShowAliens"); none := TRUE;            Texts.OpenReader(R, F.text, 0); Texts.ReadElem(R);            WHILE ~R.eot DO identify.mod[31] := 0X; R.elem.handle(R.elem, identify);                IF identify.mod[31] = 1X THEN none := FALSE; Ln; Str("pos"); Int(Texts.Pos(R) - 1);                    Str("  unknown element allocator: "); Str(identify.mod); Ch("."); Str(identify.proc)                END;                Texts.ReadElem(R)            END;            IF none THEN Str("  none") END;            Ln        END    END ShowAliens;    PROCEDURE StoreAscii*;  (*ww 21 Aug 91 / CAS 5-Nov-91*)        VAR r: Texts.Reader; t: Texts.Text; f: Files.File; fr: Files.Rider; v: Viewers.Viewer;            name, bak: ARRAY 64 OF CHAR; ch: CHAR; beg, end, time: LONGINT; i, res: INTEGER;    BEGIN t := NIL;        IF Oberon.Par.frame = Oberon.Par.vwr.dsc THEN v := Oberon.Par.vwr;            ReadName(Oberon.Par.frame(TextFrames.Frame).text, 0, name);            t := Oberon.Par.frame.next(TextFrames.Frame).text        ELSE ReadName(Oberon.Par.text, Oberon.Par.pos, name); v := Oberon.MarkedViewer();            IF (name[0] = "^") & (name[1] = 0X) THEN Oberon.GetSelection(t, beg, end, time);                IF time > 0 THEN ReadName(t, beg, name) ELSE name := "" END            END;            IF (name[0] = "*") & (name[1] = 0X) THEN ReadName(v.dsc(TextFrames.Frame).text, 0, name) END;            t := v.dsc.next(TextFrames.Frame).text        END;        IF (t # NIL) & (name # "") THEN UnmarkMenu(v);            Str("EditTools.StoreAscii "); Str(name); Ch(" ");            f := Files.New(name); Files.Set(fr, f, 0); Texts.OpenReader(r, t, 0); Texts.Read(r, ch);            WHILE ~r.eot DO                IF ch = 0DX THEN ch := 0AX END;                Files.Write(fr, ch); Texts.Read(r, ch)            END;            COPY(name, bak); i := 0;            WHILE bak[i] # 0X DO INC(i) END;            bak[i] := "."; bak[i+1] := "B"; bak[i+2] := "a"; bak[i+3] := "k"; bak[i+4] := 0X;            Files.Rename(name, bak, res);            Files.Register(f); Int(Files.Pos(fr)); Ln        END    END StoreAscii;    PROCEDURE LocateLine*;        VAR f: TextFrames.Frame;            S: Texts.Scanner; R: Texts.Reader; line, beg, end: LONGINT; ch: CHAR;    BEGIN f := MarkedFrame(); GetMainArg(S, beg, end);        WHILE ~S.eot & (S.class < Texts.Int) & (S.line = 0) DO Texts.Scan(S) END ;  (*skip names*)        IF (S.class = Texts.Int) & (f # NIL) THEN            Texts.OpenReader(R, f.text, 0); line := 1; Texts.Read(R, ch);            WHILE ~R.eot & (line < S.i) DO                IF ch = CR THEN INC(line) END;                Texts.Read(R, ch)            END;            Show(f, Texts.Pos(R)-1); TextFrames.SetCaret(f, Texts.Pos(R)-1)        END    END LocateLine;BEGIN Texts.OpenWriter(W); Texts.OpenWriter(WR); lastTime := 0; search.set := {}END EditTools.(*    EditTools.GetAttr *    EditTools.SearchAttr font Syntax10b.Scn.Fnt  off 0    EditTools.IncSize 4    EditTools.ChangeSize ? => 12 ~    EditTools.ChangeFamily ? => Syntax ~    EditTools.ChangeStyle b => . ~    EditTools.Change Syntax12.Scn.Fnt => Courier10.Scn.Fnt ~    EditTools.Words * EditTools.Mod ~    EditTools.Cleanup ~    EditTools.RemoveElems *    EditTools.ToAscii *    EditTools.InsertCR 80 @    EditTools.RemoveCR @    EditTools.StoreAscii     EditTools.LocateLine 15    test text using some mixed fonts*)