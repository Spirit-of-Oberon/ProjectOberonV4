MODULE OBC;  (*NW 30.5.87 / 28.3.93*)    IMPORT Files, OBS, OBT;    CONST ObjMark = 0F5X; CodeLength = 20000; LinkLength = 250;                ConstLength = 3500; EntryLength = 96; MaxImps = 32;                MaxPtrs = 64; MaxRecs = 32; MaxComs = 40; MaxExts = 7;        (*instruction prefixes*)            F6 = 4EH; F7 = 0CEH; F9 = 3EH; F11 = 0BEH;        (*object and item modes*)            Var   =  1; VarX  =  2; Ind   =  3; IndX  =  4; RegI  =  5;            RegX  =  6; Abs   =  7; Con   =  8; Stk   =  9; Stk0 = 10; Coc   = 11; Reg   = 12;            Fld   = 13; Typ   = 14; LProc = 15; SProc = 16; CProc = 17; IProc = 18; Mod   = 19; Head  = 20;        (*structure forms*)            Undef = 0; Byte = 1; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6;            Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11; NoTyp = 12;            Pointer = 13; ProcTyp = 14; Array = 15; DynArr = 16; Record = 17;    TYPE        Argument = RECORD            form, gen, inx: INTEGER;            d1, d2: LONGINT        END ;    VAR pc*, Pc*, level*: INTEGER;        wasderef*: OBT.Object;        typchk*: BOOLEAN;        RegSet, FRegSet: SET;        StrOffset: LONGINT;        conx, nofrecs: INTEGER;        fixlist0: ARRAY MaxImps OF INTEGER;  (*abs adr*)        fixlist1: ARRAY MaxImps OF INTEGER;  (*PC-rel adr*)        RecTab: ARRAY MaxRecs OF OBT.Struct;        constant: ARRAY ConstLength OF CHAR;        code:  ARRAY CodeLength OF CHAR;    PROCEDURE SetStrOffset*(varsize: LONGINT);    BEGIN StrOffset := -ConstLength - varsize    END SetStrOffset;    PROCEDURE GetReg*(VAR x: OBT.Item);        VAR i: INTEGER;    BEGIN i := 7; x.mode := Reg;        LOOP            IF ~(i IN RegSet) THEN x.a0 := i; INCL(RegSet,i); EXIT END ;            IF i = 0 THEN x.a0 := 0; OBS.Mark(215); EXIT ELSE DEC(i) END ;        END    END GetReg;    PROCEDURE GetFReg*(VAR x: OBT.Item);        VAR i: INTEGER;    BEGIN i := 6; x.mode := Reg;        LOOP IF ~(i IN FRegSet) THEN x.a0 := i; INCL(FRegSet,i); EXIT END ;                 IF i = 0 THEN x.a0 := 0; OBS.Mark(216); EXIT ELSE i := i-2 END        END    END GetFReg;    PROCEDURE UsedRegisters*(): SET;    BEGIN RETURN RegSet    END UsedRegisters;    PROCEDURE FreeRegs*(r: SET);    BEGIN RegSet := r; FRegSet := {}    END FreeRegs;    PROCEDURE Release*(VAR x: OBT.Item);    BEGIN        IF x.mode = Reg THEN            IF x.typ.form IN {Real, LReal} THEN EXCL(FRegSet, x.a0) ELSE EXCL(RegSet, x.a0) END        ELSIF x.mode = RegI THEN EXCL(RegSet, x.a0)        ELSIF x.mode = RegX THEN EXCL(RegSet, x.a0); EXCL(RegSet, x.a2)        ELSIF x.mode IN {VarX, IndX} THEN EXCL(RegSet, x.a2)        END    END Release;    PROCEDURE CheckCodeSize*;    BEGIN        IF pc > CodeLength - 256 THEN OBS.Mark(210); pc := 4 END    END CheckCodeSize;    PROCEDURE AllocString*(VAR s: ARRAY OF CHAR; VAR x: OBT.Item);        VAR i: INTEGER; ch: CHAR;    BEGIN (*fill constant table backward*) i := 0;        REPEAT ch := s[i]; INC(i) UNTIL ch = 0X;        x.a1 := i;        IF i <= conx THEN            REPEAT DEC(i); DEC(conx); constant[conx] := s[i] UNTIL i = 0        ELSE OBS.Mark(230)        END ;        x.a0 := conx    END AllocString;    PROCEDURE PutByte*(x: LONGINT);    BEGIN code[pc] := CHR(x); INC(pc)    END PutByte;    PROCEDURE PutWord*(x: LONGINT); (*high byte first*)    BEGIN code[pc] := CHR(x DIV 100H); INC(pc); code[pc] := CHR(x); INC(pc)    END PutWord;    PROCEDURE PutDbl*(x: LONGINT);        VAR i: INTEGER;    BEGIN i := -32;        REPEAT INC(i, 8); code[pc] := CHR(ASH(x, i)); INC(pc) UNTIL i = 0    END PutDbl;    PROCEDURE PutF3*(op: INTEGER);    BEGIN code[pc] := CHR(op); INC(pc); code[pc] := CHR(op DIV 100H); INC(pc)    END PutF3;    PROCEDURE PutExtAdr*(mno: INTEGER; pno: LONGINT);    BEGIN PutWord(pno - 4000H); PutF3(fixlist1[mno]); fixlist1[mno] := pc - 4    END PutExtAdr;    PROCEDURE PutDisp*(x: LONGINT);    BEGIN        IF x < 0 THEN            IF x >= -40H THEN code[pc] := CHR(x+80H); INC(pc)            ELSIF x >= -2000H THEN PutWord(x+0C000H)            ELSE PutDbl(x)            END        ELSIF x < 40H THEN code[pc] := CHR(x); INC(pc)        ELSIF x < 2000H THEN PutWord(x+8000H)        ELSE PutDbl(x - 40000000H)        END    END PutDisp;    PROCEDURE PutArg(VAR z: Argument);    BEGIN        CASE z.form OF            0:   IF z.inx = 1 THEN code[pc] := CHR(z.d1); INC(pc)                    ELSIF z.inx = 2 THEN PutWord(z.d1)                    ELSIF z.inx = 4 THEN PutDbl(z.d1)                    ELSIF z.inx = 8 THEN PutDbl(z.d2); PutDbl(z.d1)                    END        | 1:        | 2,6: PutDisp(z.d1)        | 3,7: PutDisp(z.d1); PutDisp(z.d2)        | 4,8: PutDisp(z.d1 - Pc)        | 5,9: PutWord(z.d1 - 4000H); PutF3(fixlist0[z.d2]); fixlist0[z.d2] := pc - 4        END    END PutArg;    PROCEDURE Operand(VAR x: OBT.Item; VAR z: Argument);        PROCEDURE downlevel(VAR gen: INTEGER);            VAR n, op: INTEGER; b: OBT.Item;        BEGIN GetReg(b); n := level - x.lev; gen := SHORT(b.a0) + 8;            op := SHORT(b.a0)*40H - 3FE9H;            IF n = 1 THEN PutF3(op); PutDisp(8);  (*MOVD 8(FP) Rb*)            ELSE PutF3(op - 4000H); PutDisp(8); PutDisp(8);  (*MOVD 8(8(FP)) Rb*)                WHILE n > 2 DO DEC(n);                    PutF3((SHORT(b.a0)*20H + SHORT(b.a0))*40H + 4017H); PutDisp(8)                END            END ;        END downlevel;        PROCEDURE index;            VAR s: LONGINT;        BEGIN s := x.typ.size;            IF s = 1 THEN z.gen := 1CH            ELSIF s = 2 THEN z.gen := 1DH            ELSIF s = 4 THEN z.gen := 1EH            ELSIF s = 8 THEN z.gen := 1FH            ELSE z.gen := 1CH; PutByte(F7); PutByte(x.a2 MOD 4 * 40H + 23H);   (*MULD s, r*)                PutByte(x.a2 DIV 4 + 0A0H); PutWord(0); PutWord(s)            END        END index;    BEGIN        CASE x.mode OF             Var:  IF x.lev = 0 THEN                             z.gen := 1BH; z.d1 := x.a0; z.form := 4                         ELSIF x.lev < 0 THEN                             z.gen := 15H; z.d1 := x.a0; z.d2 := -x.lev; z.form := 5                         ELSIF x.lev = level THEN                             z.gen := 18H; z.d1 := x.a0; z.form := 2                         ELSIF x.lev+1 = level THEN                             z.gen := 10H; z.d1 := 8; z.d2 := x.a0; z.form := 3                         ELSE downlevel(z.gen); z.d1 := x.a0; z.form := 2                         END         | Ind:  IF x.lev <= 0 THEN OBS.Mark(240)                         ELSIF x.lev = level THEN                             z.gen := 10H; z.d1 := x.a0; z.d2 := x.a1; z.form := 3                         ELSE downlevel(z.gen);                             PutF3((z.gen*20H + z.gen-8)*40H + 17H); PutDisp(x.a0);                             z.d1 := x.a1; z.form := 2                         END         | RegI: z.gen := SHORT(x.a0)+8; z.d1 := x.a1; z.form := 2         | VarX: index;                         IF x.lev = 0 THEN                             z.inx := 1BH; z.d1 := x.a0; z.form := 8                         ELSIF x.lev < 0 THEN                             z.inx := 15H; z.d1 := x.a0; z.d2 := -x.lev; z.form := 9                         ELSIF x.lev = level THEN                             z.inx := 18H; z.d1 := x.a0; z.form := 6                         ELSIF x.lev+1 = level THEN                             z.inx := 10H;  z.d1 := 8; z.d2 := x.a0; z.form := 7                         ELSE downlevel(z.inx); z.d1 := x.a0; z.form := 6                         END ;                         z.inx := z.inx*8 + SHORT(x.a2)         | IndX: index;                         IF x.lev <= 0 THEN OBS.Mark(240)                         ELSIF x.lev = level THEN                             z.inx := 10H; z.d1 := x.a0; z.d2 := x.a1; z.form := 7                         ELSE downlevel(z.inx);                             PutF3((z.inx*20H + z.inx-8)*40H + 17H); PutDisp(x.a0);                             z.d1 := x.a1; z.form := 6                         END ;                         z.inx := z.inx * 8 + SHORT(x.a2)         | RegX: index; z.inx := SHORT((x.a0+8)*8 + x.a2); z.d1 := x.a1; z.form := 6         | Con:  z.form := 0;                        CASE x.typ.form OF                             Undef, Byte, Bool, Char, SInt:                                 z.gen := 14H; z.inx := 1; z.d1 := x.a0                         | Int:                                 z.gen := 14H; z.inx := 2; z.d1 := x.a0                         | LInt, Real, Set, Pointer, ProcTyp, NilTyp:                                 z.gen := 14H; z.inx := 4; z.d1 := x.a0                         | LReal:                                 z.gen := 14H; z.inx := 8; z.d1 := x.a0; z.d2 := x.a1                         | String:                                 z.form := 4; z.gen := 1BH; z.d1 := x.a0 + StrOffset                         END         | Reg:  z.gen := SHORT(x.a0); z.form := 1         | Stk:  z.gen := 17H;  z.form := 1         | Stk0: z.gen := 19H; z.form := 2; z.d1 := 0         | Abs:  z.gen := 15H; z.form := 2; z.d1 := x.a0         | Coc, Fld .. Head: OBS.Mark(126); x.mode := Var; z.form := 0        END    END Operand;    PROCEDURE PutF0*(cond: LONGINT);    BEGIN code[pc] := CHR(cond*10H + 10); INC(pc)    END PutF0;    PROCEDURE PutF1*(op: INTEGER);    BEGIN code[pc] := CHR(op); INC(pc)    END PutF1;    PROCEDURE PutF2*(op: INTEGER; short: LONGINT; VAR x: OBT.Item);        VAR dst: Argument;    BEGIN Operand(x, dst); Pc := pc;        code[pc] := CHR(SHORT(short) MOD 2 * 80H + op); INC(pc);        code[pc] := CHR(dst.gen*8 + SHORT(short) MOD 10H DIV 2);        INC(pc);        IF dst.form >= 6 THEN code[pc] := CHR(dst.inx); INC(pc) END ;        PutArg(dst)    END PutF2;    PROCEDURE PutF4*(op: INTEGER; VAR x, y: OBT.Item);        VAR dst, src: Argument;    BEGIN Operand(x, dst); Operand(y, src); Pc := pc;        code[pc] := CHR(dst.gen MOD 4 * 40H + op); INC(pc);        code[pc] := CHR(src.gen*8 + dst.gen DIV 4); INC(pc);        IF src.form >= 6 THEN code[pc] := CHR(src.inx); INC(pc) END ;        IF dst.form >= 6 THEN code[pc] := CHR(dst.inx); INC(pc) END ;        PutArg(src); PutArg(dst)    END PutF4;    PROCEDURE Put*(F, op: INTEGER; VAR x, y: OBT.Item);        VAR dst, src: Argument;    BEGIN Operand(x, dst); Operand(y, src); Pc := pc; code[pc] := CHR(F); INC(pc);        code[pc] := CHR(dst.gen MOD 4 * 40H + op); INC(pc);        code[pc] := CHR(src.gen*8 + dst.gen DIV 4); INC(pc);        IF src.form >= 6 THEN code[pc] := CHR(src.inx); INC(pc) END ;        IF dst.form >= 6 THEN code[pc] := CHR(dst.inx); INC(pc) END ;        PutArg(src); PutArg(dst)    END Put;    PROCEDURE RegisterRecType*(typ: OBT.Struct);    BEGIN        IF typ.extlev > MaxExts THEN OBS.Mark(233)        ELSIF nofrecs < MaxRecs THEN            RecTab[nofrecs] := typ; INC(nofrecs);            IF level > 0 THEN DEC(conx, 4); typ.adr := conx + StrOffset END        ELSE OBS.Mark(223)        END    END RegisterRecType;    PROCEDURE SaveRegisters*(VAR gR, fR: SET; VAR x: OBT.Item);        VAR i, r, m: INTEGER; t: SET;    BEGIN t := RegSet;        IF x.mode IN {Reg, RegI, RegX} THEN EXCL(RegSet, x.a0) END ;        IF x.mode IN {VarX, IndX, RegX} THEN EXCL(RegSet, x.a2) END ;        gR := RegSet; fR := FRegSet;        IF RegSet # {} THEN            i := 0; r := 1; m := 0;            REPEAT                IF i IN RegSet THEN INC(m, r) END ;                INC(r, r); INC(i)            UNTIL i = 8;            PutF1(62H); PutByte(m)        END ;        RegSet := t - RegSet; i := 0;        WHILE FRegSet # {} DO            IF i IN FRegSet THEN                PutF1(F11); PutF3(i*800H + 5C4H); EXCL(FRegSet, i)            END ;            INC(i, 2)        END    END SaveRegisters;    PROCEDURE RestoreRegisters*(gR, fR: SET; VAR x: OBT.Item);        VAR i, r, m: INTEGER; y: OBT.Item;    BEGIN RegSet := gR; FRegSet := fR; i := 8;        (*set result mode*) x.mode := Reg; x.a0 := 0;        IF (x.typ.form = Real) OR (x.typ.form = LReal) THEN            IF 0 IN fR THEN GetFReg(y); Put(F11, 4, y, x); x.a0 := y.a0 END ;            INCL(FRegSet, 0)        ELSE            IF 0 IN gR THEN GetReg(y); PutF4(17H, y, x); x.a0 := y.a0 END ;            INCL(RegSet, 0)        END ;        WHILE fR # {} DO            DEC(i, 2);            IF i IN fR THEN                PutF1(F11); PutF3(i*40H - 47FCH); EXCL(fR, i)            END        END ;        IF gR # {} THEN            i := 8; r := 1; m := 0;            REPEAT DEC(i);                IF i IN gR THEN INC(m, r) END ;                INC(r, r)            UNTIL i = 0;            PutF1(72H); PutF1(m)        END    END RestoreRegisters;    PROCEDURE DynArrAdr*(VAR x, y: OBT.Item);   (* x := ADR(y) *)        VAR l, r: OBT.Item;    BEGIN        WHILE y.typ.form = DynArr DO    (* index with 0 *)            IF y.mode = IndX THEN                l.mode := Var; l.a0 := y.a0 + y.typ.adr; l.lev := y.lev;                (* l = actual dimension length *)                r.mode := Reg; r.a0 := y.a2; Put(F7, 23H, r, l)   (*MULD len, r*)            END;            y.typ := y.typ.BaseTyp        END;        IF (y.mode = Var) OR (y.mode = Ind) & (y.a1 = 0) THEN            y.mode := Var; PutF4(17H, x, y) (* MOVD *)        ELSE PutF4(27H, x, y); x.a1 := 0    (* ADDR *)        END    END DynArrAdr;        PROCEDURE fixup*(loc: LONGINT);  (*enter pc at loc*)        VAR x: LONGINT;    BEGIN x := pc - loc + 8001H;        code[loc] := CHR(x DIV 100H); code[loc+1] := CHR(x)    END fixup;    PROCEDURE fixupC*(loc: LONGINT);        VAR x: LONGINT;    BEGIN x := pc+1 - loc;        IF x > 3 THEN            IF x < 2000H THEN                code[loc] := CHR(x DIV 100H + 80H); code[loc+1] := CHR(x)            ELSE OBS.Mark(211)            END        ELSE DEC(pc, 3)        END    END fixupC;    PROCEDURE fixupL*(loc: LONGINT);        VAR x: LONGINT;    BEGIN x := pc+1 - loc;        IF x > 5 THEN            code[loc+2] := CHR(x DIV 100H); code[loc+3] := CHR(x)        ELSE DEC(pc, 5)        END    END fixupL;    PROCEDURE FixLink*(L: LONGINT);        VAR L1: LONGINT;    BEGIN         WHILE L # 0 DO            L1 := ORD(code[L])*100H + ORD(code[L+1]);            fixup(L); L := L1        END    END FixLink;    PROCEDURE FixupWith*(L, val: LONGINT);        VAR x: LONGINT;    BEGIN x := val MOD 4000H + 8000H;        IF ABS(val) >= 2000H THEN OBS.Mark(208) END ;        code[L] := CHR(x DIV 100H); code[L+1] := CHR(x)    END FixupWith;    PROCEDURE FixLinkWith*(L, val: LONGINT);        VAR L1: LONGINT;    BEGIN         WHILE L # 0 DO            L1 := ORD(code[L])*100H + ORD(code[L+1]);            FixupWith(L, val+1 - L); L := L1        END    END FixLinkWith;    PROCEDURE FixupImm*(loc: INTEGER; val: LONGINT);        VAR i: INTEGER;    BEGIN i := 4;        REPEAT DEC(i); DEC(loc); code[loc] := CHR(val); val := val DIV 100H UNTIL i = 0    END FixupImm;    PROCEDURE MergedLinks*(L0, L1: LONGINT): LONGINT;        VAR L2, L3: LONGINT;    BEGIN (*merge chains of the two operands of AND and OR *)        IF L0 # 0 THEN L2 := L0;            LOOP L3 := ORD(code[L2])*100H + ORD(code[L2+1]);                IF L3 = 0 THEN EXIT END ;                L2 := L3            END ;            code[L2] := CHR(L1 DIV 100H); code[L2+1] := CHR(L1);            RETURN L0        ELSE RETURN L1        END    END MergedLinks;    PROCEDURE Init*;        VAR i: INTEGER;    BEGIN pc := 0; level := 0; conx := ConstLength; nofrecs := 0; RegSet := {}; FRegSet := {}; i := 0;        REPEAT fixlist0[i] := 0; fixlist1[i] := 0; INC(i) UNTIL i = MaxImps    END Init;    PROCEDURE FindPtrs(typ: OBT.Struct; badr: LONGINT;            VAR ptab: ARRAY OF LONGINT; VAR n: INTEGER);        (*find all pointers in typ and enter their offsets (+badr) in ptab*)        VAR fld: OBT.Object; btyp: OBT.Struct;            i, m, s: LONGINT;    BEGIN        IF typ.form = Pointer THEN            IF n < MaxPtrs THEN ptab[n] := badr; INC(n) ELSE OBS.Mark(222) END        ELSIF typ.form = Record THEN            btyp := typ.BaseTyp;            IF btyp # NIL THEN FindPtrs(btyp, badr, ptab, n) END ;            fld := typ.link;            WHILE fld # NIL DO                IF fld.name # "" THEN FindPtrs(fld.typ, fld.a0 + badr, ptab, n)                ELSIF n < MaxPtrs THEN ptab[n] := fld.a0 + badr; INC(n)                ELSE OBS.Mark(222)                END ;                fld := fld.next            END        ELSIF typ.form = Array THEN            btyp := typ.BaseTyp; m := typ.size DIV btyp.size;            WHILE btyp.form = Array DO                m := btyp.size DIV btyp.BaseTyp.size * m; btyp := btyp.BaseTyp            END ;            IF (btyp.form = Pointer) OR (btyp.form = Record) THEN                i := 0; s := btyp.size;                WHILE i < m DO FindPtrs(btyp, i*s + badr, ptab, n); INC(i) END            END        END    END FindPtrs;    PROCEDURE OutCode*(VAR name, progid: ARRAY OF CHAR;                    key: LONGINT; datasize: LONGINT);        VAR f, i, m, np, L, L1: INTEGER;            s, s0, refpos: LONGINT;            nofent, nofcom, nofptrs, comsize: INTEGER;            obj:    OBT.Object;            typ:    OBT.Struct;            ObjFile:   Files.File;            out:    Files.Rider;            PtrTab: ARRAY MaxPtrs OF LONGINT;            ComTab: ARRAY MaxComs OF OBT.Object;        PROCEDURE W(n: INTEGER);        BEGIN Files.Write(out, CHR(n)); Files.Write(out, CHR(n DIV 100H))        END W;        PROCEDURE WriteName(VAR name: ARRAY OF CHAR);            VAR i: INTEGER; ch: CHAR;        BEGIN i := 0;            REPEAT ch := name[i]; Files.Write(out, ch); INC(i) UNTIL ch = 0X        END WriteName;        PROCEDURE Collect;            (*collect commands, and pointers*)            VAR obj, par: OBT.Object; u: INTEGER;        BEGIN obj := OBT.topScope.next;            WHILE obj # NIL DO                IF obj.mode = LProc THEN                    IF obj.a0 = 0 THEN OBS.Mark(129)                    ELSIF obj.marked & (obj.typ.form = NoTyp) THEN                        par := obj.dsc;                        IF (par = NIL) OR (par.mode > 3) OR (par.a0 < 0) THEN (*command*)                            u := 0;                            WHILE obj.name[u] > 0X DO INC(comsize); INC(u) END ;                            INC(comsize, 3);                            IF nofcom < MaxComs THEN ComTab[nofcom] := obj; INC(nofcom)                            ELSE OBS.Mark(232); nofcom := 0; comsize := 0                            END                        END                    END                ELSIF obj.mode = Var THEN FindPtrs(obj.typ, obj.a0, PtrTab, nofptrs)                END ;                obj := obj.next            END        END Collect;        PROCEDURE OutBaseTypes(typ: OBT.Struct);        BEGIN            IF typ.BaseTyp # NIL THEN                OutBaseTypes(typ.BaseTyp); Files.Write(out, CHR(typ.mno)); Files.WriteLInt(out, typ.adr)            END        END OutBaseTypes;        PROCEDURE OutRefBlk(first: OBT.Object; pc: INTEGER; name: ARRAY OF CHAR);            VAR obj: OBT.Object;        BEGIN obj := first;            WHILE obj # NIL DO                IF obj.mode IN {LProc, IProc} THEN OutRefBlk(obj.dsc, obj.a2, obj.name) END ;                obj := obj.next            END ;            Files.Write(out, 0F8X); Files.WriteInt(out, pc); Files.WriteString(out, name);            obj := first;            WHILE obj # NIL DO                IF (obj.mode = Var) OR (obj.mode = Ind) THEN                    f := obj.typ.form;                    IF (f IN {Byte .. Set, Pointer})                        OR (f = Array) & (obj.typ.BaseTyp.form = Char) THEN                        Files.Write(out, CHR(obj.mode)); Files.Write(out, CHR(f));                        Files.WriteLInt(out, obj.a0); Files.WriteString(out, obj.name)                    END                END ;                obj:= obj.next            END        END OutRefBlk;    BEGIN ObjFile := Files.New(name);        IF ObjFile # NIL THEN            Files.Set(out, ObjFile, 0);            WHILE pc MOD 4 # 0 DO PutF1(0A2H) END ; (*NOP*)            DEC(conx, conx MOD 4);            nofcom := 0; comsize := 1; nofptrs := 0;            WHILE nofptrs < nofrecs DO PtrTab[nofptrs] := RecTab[nofptrs].adr; INC(nofptrs) END ;            Collect; L := fixlist0[0];        (*header block*)            Files.Write(out, ObjMark); Files.Write(out, "0"); Files.WriteLInt(out, refpos);            Files.WriteInt(out, OBT.nofGmod); Files.WriteInt(out, OBT.entno);            Files.WriteInt(out, nofptrs); Files.WriteInt(out, comsize);            Files.WriteInt(out, ConstLength - conx); Files.WriteLInt(out, datasize);            Files.WriteInt(out, pc); Files.WriteInt(out, nofrecs);            Files.WriteLInt(out, key); Files.WriteString(out, progid);        (*import block*)            i := 0;            WHILE i < OBT.nofGmod DO                obj := OBT.GlbMod[i];                Files.WriteLInt(out, obj.a1); Files.WriteString(out, obj.name); INC(i)            END ;        (*entry block*)            Files.WriteBytes(out, OBT.entry, 2*OBT.entno);        (*pointer block*) i := 0;            WHILE i < nofptrs DO                IF PtrTab[i] < -4000H THEN OBS.Mark(225) END ;                Files.WriteInt(out, SHORT(PtrTab[i])); INC(i)            END ;        (*command block*) i := 0;            WHILE i < nofcom DO                obj := ComTab[i]; Files.WriteString(out, obj.name);                Files.WriteInt(out, SHORT(obj.a0)); INC(i)            END ;            Files.Write(out, 0X);        (*constants block*) i := conx;            WHILE i < ConstLength DO Files.Write(out, constant[i]); INC(i) END ;        (*code block*)            Files.WriteBytes(out, code, pc);        (*fixups*) i := 0;            WHILE i < OBT.nofGmod DO                INC(i); Files.WriteInt(out, fixlist0[i]); Files.WriteInt(out, fixlist1[i])            END ;        (*typdesc block*) i := 0;            WHILE i < nofrecs DO                typ := RecTab[i]; RecTab[i] := NIL; INC(i);                s := typ.size + 4; m := 4; s0 := 16;                WHILE (m > 0) & (s > s0) DO INC(s0, s0); DEC(m) END ;                IF s > s0 THEN s0 := (s+127) DIV 128 * 128 END ;                np := 0; FindPtrs(typ, 0, PtrTab, np); s := np*2 + (MaxExts+1)*4;                Files.WriteInt(out, SHORT(s)); Files.WriteInt(out, SHORT(typ.adr));   (*td size/adr*)                s := LONG(np)*1000000H + s0; Files.WriteLInt(out, s);    (*head of typdesc*)                Files.Write(out, CHR(typ.extlev)); OutBaseTypes(typ);                Files.Write(out, CHR(np)); m := 0;                WHILE m < np DO Files.WriteInt(out, SHORT(PtrTab[m])); INC(m) END            END ;        (*ref block*)            refpos := Files.Pos(out);            OutRefBlk(OBT.topScope.next, pc, "$$");            Files.Set(out, ObjFile, 2); Files.WriteLInt(out, refpos);        IF ~OBS.scanerr THEN Files.Register(ObjFile) END        ELSE OBS.Mark(153)        END    END OutCode;BEGIN NEW(wasderef)END OBC.