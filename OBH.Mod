MODULE OBH;    (*NW 7.6.87 / 11.7.93*)	IMPORT OBS, OBT, OBC;	CONST		(*instruction format prefixes*)			F6 = 4EH; F7 = 0CEH; F9 = 3EH; F11 = 0BEH;		(*object and item modes*)			Var   =  1; VarX  =  2; Ind   =  3; IndX  =  4; RegI  =  5;			RegX  =  6; Abs   =  7; Con   =  8; Stk   =  9; Stk0 = 10; Coc   = 11; Reg   = 12;			Fld   = 13; LProc = 15; CProc = 17; IProc = 18; Mod   = 19;		(*structure forms*)			Undef = 0; Byte = 1; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6;			Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11; NoTyp = 12;			Pointer = 13; ProcTyp = 14; Array = 15; DynArr = 16; Record = 17;	TYPE LabelRange* = RECORD low*, high*: INTEGER; label*: INTEGER END ;	VAR clrchk*, stkchk*: BOOLEAN;		lengcode: ARRAY 18 OF INTEGER;	PROCEDURE setCC(VAR x: OBT.Item; cc: LONGINT);	BEGIN		x.typ := OBT.booltyp; x.mode := Coc; x.a0 := cc; x.a1 := 0; x.a2 := 0	END setCC;	PROCEDURE AdjustSP*(n: LONGINT);	BEGIN  (*ADJSPB n*)		IF n <= 127 THEN OBC.PutF3(-5A84H); OBC.PutByte(n)		ELSE OBC.PutF3(-5A83H); OBC.PutWord(n)		END	END AdjustSP;	PROCEDURE move(L: INTEGER; VAR x, y: OBT.Item);	BEGIN		IF (y.mode = Con) & (y.a0 <= 7) & (y.a0 >= -8) THEN OBC.PutF2(L+5CH, y.a0, x)  (*MOVQi*)		ELSE OBC.PutF4(L+14H, x, y)  (*MOVi*)		END	END move;		PROCEDURE load(VAR x: OBT.Item);		VAR y: OBT.Item;	BEGIN IF x.mode # Reg THEN y := x; OBC.GetReg(x); move(lengcode[x.typ.form], x, y) END	END load;	PROCEDURE moveBW(VAR x, y: OBT.Item);	BEGIN		IF (y.mode = Con) & (y.a0 <= 7) & (y.a0 >= -8) THEN OBC.PutF2(5DH, y.a0, x)		ELSE OBC.Put(F7, 10H, x, y)  (*MOVXBW*)		END	END moveBW;	PROCEDURE moveBD(VAR x, y: OBT.Item);	BEGIN		IF (y.mode = Con) & (y.a0 <= 7) & (y.a0 >= -8) THEN OBC.PutF2(5FH, y.a0, x)		ELSE OBC.Put(F7, 1CH, x, y)  (*MOVXBD*)		END	END moveBD;	PROCEDURE moveWD(VAR x, y: OBT.Item);	BEGIN		IF (y.mode = Con) & (y.a0 <= 7) & (y.a0 >= -8) THEN OBC.PutF2(5FH, y.a0, x)		ELSE OBC.Put(F7, 1DH, x, y)  (*MOVXWD*)		END	END moveWD;	PROCEDURE Leng(VAR x: OBT.Item; L: LONGINT);		VAR y: OBT.Item;	BEGIN		IF L <= 7 THEN OBC.PutF2(5FH, L, x)       (*MOVQD*)		ELSE y.mode := Con; y.a0 := L; y.typ := OBT.linttyp; OBC.PutF4(17H, x, y)		END	END Leng;	PROCEDURE MoveBlock(VAR x, y: OBT.Item; s: LONGINT; param: BOOLEAN);		VAR L: INTEGER; z: OBT.Item;	BEGIN		IF s > 0 THEN			IF param THEN s := (s+3) DIV 4 * 4; AdjustSP(s) END ;			IF s <= 16 THEN				OBC.Put(F7, 0, x, y); OBC.PutDisp(s-1)   (*MOVMB*)			ELSE				z.mode := Reg; z.a0 := 1; OBC.PutF4(27H, z, y);    (*ADDR y,R1*)				z.a0 := 2; OBC.PutF4(27H, z, x); z.a0 := 0;        (*ADDR x,R2*)				IF s MOD 4 = 0 THEN L := 3; s := s DIV 4				ELSIF s MOD 2 = 0 THEN L := 1; s := s DIV 2				ELSE L := 0				END ;				Leng(z, s);				OBC.PutF1(14); OBC.PutByte(L); OBC.PutByte(0)      (*MOVS*)			END		END	END MoveBlock;	PROCEDURE DynArrBnd(ftyp, atyp: OBT.Struct; lev: INTEGER; adr: LONGINT; varpar: BOOLEAN);		VAR f: INTEGER; x, y, z: OBT.Item;	BEGIN (* ftyp.form = DynArr *)		x.mode := Stk; y.mode := Var;		IF varpar & (ftyp.BaseTyp.form = Byte) THEN			IF atyp.form # DynArr THEN				IF (atyp.form # Array) OR (atyp.BaseTyp.size > 1) THEN OBS.Mark(-1) END ;				Leng(x, atyp.size)			ELSE y.lev := lev; y.a0 := adr + atyp.adr; y.typ := OBT.linttyp;				atyp := atyp.BaseTyp;				IF atyp.form # DynArr THEN					IF atyp.size > 1 THEN						OBS.Mark(-1); z.mode := Con; z.typ := OBT.linttyp; z.a0 := atyp.size;						load(y); OBC.Put(F7, 23H, y, z);	(* MULD z, Ry *)						z.mode := Con; z.typ := OBT.linttyp; z.a0 := atyp.size					END				ELSE OBS.Mark(-1); load(y); OBC.PutF2(0FH, 1, y);					REPEAT z.mode := Var; z.lev := lev; z.a0 := atyp.adr + adr; z.typ := OBT.linttyp;						load(z); OBC.Put(F7, 23H, y, z);	(* MULD Rz, Ry *)						atyp := atyp.BaseTyp					UNTIL atyp.form # DynArr;					IF atyp.size > 1 THEN						z.mode := Con; z.typ := OBT.linttyp; z.a0 := atyp.size;						OBC.Put(F7, 23H, y, z)	(* MULD z, Ry *)					END				END ;				OBC.PutF4(17H, x, y)	(* MOVD apdynarrlen, TOS *)			END		ELSE			LOOP f := atyp.form;				IF f = Array THEN Leng(x, atyp.size DIV atyp.BaseTyp.size)				ELSIF f = DynArr THEN y.lev := lev; y.a0 := atyp.adr + adr; OBC.PutF4(17H, x, y)				ELSE OBS.Mark(66); EXIT				END ;				ftyp := ftyp.BaseTyp; atyp := atyp.BaseTyp;				IF ftyp.form # DynArr THEN					IF ftyp # atyp THEN						IF ~varpar & (ftyp.form = Pointer) & (atyp.form = Pointer) THEN							ftyp := ftyp.BaseTyp; atyp := atyp.BaseTyp;							IF (ftyp.form = Record) & (atyp.form = Record) THEN								WHILE (ftyp # atyp) & (atyp # NIL) DO atyp := atyp.BaseTyp END ;								IF atyp = NIL THEN OBS.Mark(113) END							ELSE OBS.Mark(67)							END						ELSE OBS.Mark(67)						END					END ;					EXIT				END			END		END	END DynArrBnd;	PROCEDURE Trap*(n: INTEGER);	BEGIN OBC.PutF1(0F2H); OBC.PutByte(n)  (*BPT n*)	END Trap;	PROCEDURE CompareParLists*(x, y: OBT.Object);		VAR xt, yt: OBT.Struct;	BEGIN		WHILE x # NIL DO			IF y # NIL THEN				xt := x.typ; yt := y.typ;				WHILE (xt.form = DynArr) & (yt.form = DynArr) DO					xt := xt.BaseTyp; yt := yt.BaseTyp				END ;				IF x.mode # y.mode THEN OBS.Mark(115)				ELSIF xt # yt THEN					IF (xt.form = ProcTyp) & (yt.form = ProcTyp) THEN						CompareParLists(xt.link, yt.link)					ELSE OBS.Mark(115)					END				END ;				y := y.next			ELSE OBS.Mark(116)			END ;			x := x.next		END ;		IF (y # NIL) & (y.mode <= Ind) & (y.a0 > 0) THEN OBS.Mark(117) END	END CompareParLists;	PROCEDURE Assign*(VAR x, y: OBT.Item; param: BOOLEAN);		VAR f, g, L, u: INTEGER; s, vsz: LONGINT;				p, q: OBT.Struct;				tag, tdes: OBT.Item;	BEGIN f := x.typ.form; g := y.typ.form;		IF x.mode = Con THEN OBS.Mark(56)		ELSIF (x.mode IN {Var, VarX}) & (x.lev < 0) THEN OBS.Mark(-3)		END ;		CASE f OF		Undef, String:	| Byte: IF g IN {Undef, Byte, Char, SInt} THEN						IF param THEN moveBD(x, y) ELSE move(0, x, y) END					ELSE OBS.Mark(113)					END	| Bool: IF param THEN u := 3 ELSE u := 0 END ;					IF y.mode = Coc THEN						IF (y.a1 = 0) & (y.a2 = 0) THEN OBC.PutF2(u+3CH, y.a0, x)						ELSE							IF ODD(y.a0) THEN OBC.PutF0(y.a0-1) ELSE OBC.PutF0(y.a0+1) END ;							OBC.PutWord(y.a2); y.a2 := OBC.pc-2;							OBC.FixLink(y.a1); OBC.PutF2(u+5CH, 1, x);							OBC.PutF0(14); L := OBC.pc; OBC.PutWord(0);							OBC.FixLink(y.a2); OBC.PutF2(u+5CH, 0, x); OBC.fixup(L)						END					ELSIF g = Bool THEN						IF y.mode = Con THEN OBC.PutF2(u+5CH, y.a0, x)						ELSIF param THEN OBC.Put(F7, 18H, x, y)  (*MOVZBD*)						ELSE OBC.PutF4(14H, x, y)						END					ELSE OBS.Mark(113)					END	| Char, SInt:					IF g = f THEN						IF param THEN moveBD(x, y) ELSE move(0, x, y) END					ELSE OBS.Mark(113)					END	| Int:  IF g = Int THEN						IF param THEN moveWD(x, y) ELSE move(1, x, y) END					ELSIF g = SInt THEN						IF param THEN moveBD(x, y) ELSE moveBW(x, y) END					ELSE OBS.Mark(113)					END	| LInt: IF g = LInt THEN move(3, x, y)					ELSIF g = Int THEN moveWD(x, y)					ELSIF g = SInt THEN moveBD(x, y)					ELSE OBS.Mark(113)					END	| Real: IF g = Real THEN OBC.Put(F11, 5, x, y)					ELSIF (SInt <= g) & (g <= LInt) THEN OBC.Put(F9, lengcode[g]+4, x, y)					ELSE OBS.Mark(113)					END	| LReal:IF g = LReal THEN OBC.Put(F11, 4, x, y)					ELSIF g = Real THEN OBC.Put(F9, 1BH, x, y)					ELSIF (SInt <= g) & (g <= LInt) THEN OBC.Put(F9, lengcode[g], x, y)					ELSE OBS.Mark(113)					END	| Set:  IF g = f THEN move(3, x, y) ELSE OBS.Mark(113) END	| Pointer:					IF x.typ = y.typ THEN move(3, x, y)					ELSIF g = NilTyp THEN OBC.PutF2(5FH, 0, x)					ELSIF g = Pointer THEN						p := x.typ.BaseTyp; q := y.typ.BaseTyp;						IF (p.form = Record) & (q.form = Record) THEN							WHILE (q # p) & (q # NIL) DO q := q.BaseTyp END ;							IF q # NIL THEN move(3, x, y) ELSE OBS.Mark(113) END						ELSE OBS.Mark(113)						END					ELSE OBS.Mark(113)					END	| Array: s := x.typ.size;					IF x.typ = y.typ THEN MoveBlock(x, y, s, param)					ELSIF (g = String) & (x.typ.BaseTyp.form = Char) THEN						s := y.a1; vsz := x.typ.size;  (*check length of string*)						IF s > vsz THEN OBS.Mark(114) END ;						IF param THEN							vsz := (vsz+3) DIV 4 - (s+3) DIV 4;							IF vsz > 0 THEN AdjustSP(vsz*4) END						END ;						MoveBlock(x, y, s, param)					ELSE OBS.Mark(113)					END	| DynArr: s := x.typ.size;					IF param THEN (*formal parameter is open array*)						IF (g = String) & (x.typ.BaseTyp.form = Char) THEN Leng(x, y.a1)						ELSIF y.mode >= Abs THEN OBS.Mark(59)						ELSE DynArrBnd(x.typ, y.typ, y.lev, y.a0, FALSE)						END ;						IF g = DynArr THEN OBC.DynArrAdr(x, y)						ELSE OBC.PutF4(27H, x, y)						END					ELSE OBS.Mark(113)					END	| Record: s := x.typ.size;					IF x.typ # y.typ THEN						IF g = Record THEN							q := y.typ.BaseTyp;							WHILE (q # NIL) & (q # x.typ) DO q := q.BaseTyp END ;							IF q = NIL THEN OBS.Mark(113) END						ELSE OBS.Mark(113)						END					END;					IF OBC.typchk & ~param &						( ((x.mode = Ind) OR (x.mode = RegI)) & (x.obj = OBC.wasderef)	(* p^ := *)							OR (x.mode = Ind) & (x.obj # NIL) & (x.obj # OBC.wasderef) )	(* varpar := *) THEN						tag := x; tdes.mode := Var; tdes.lev := -x.typ.mno; tdes.a0 := x.typ.adr;						IF x.obj = OBC.wasderef THEN tag.a1 := - 4						ELSE tag.mode := Var; INC(tag.a0, 4)						END;						OBC.PutF4(7, tdes, tag);	(* CMPD tag, tdes *)						OBC.PutF0(0); OBC.PutDisp(4);	(* BEQ continue *)						OBC.PutF1(0F2H); OBC.PutByte(19)	(* BPT 19 *)					END;					MoveBlock(x, y, s, param)	| ProcTyp:					IF (x.typ = y.typ) OR (y.typ.form = NilTyp) THEN OBC.PutF4(17H, x, y)					ELSIF (y.mode = LProc) & (y.lev <= 0) OR (y.mode = IProc) THEN						(*procedure y to proc. variable x; check compatibility*)						IF x.typ.BaseTyp = y.typ THEN							CompareParLists(x.typ.link, y.obj.dsc);							IF (y.a0 = 0) & (y.lev >= 0) THEN OBS.Mark(235) (*forward*) END ;							y.mode := Var; OBC.PutF4(27H, x, y)   (*ADDR*)						ELSE OBS.Mark(118)						END					ELSE OBS.Mark(111)					END	| NoTyp, NilTyp: OBS.Mark(111)		END	END Assign;	PROCEDURE FJ*(VAR loc: INTEGER);	BEGIN OBC.PutF0(14); OBC.PutWord(loc); loc := OBC.pc-2	END FJ;	PROCEDURE CFJ*(VAR x: OBT.Item; VAR loc: INTEGER);	BEGIN		IF x.typ.form = Bool THEN			IF x.mode # Coc THEN OBC.PutF2(1CH, 1, x); setCC(x, 0) END		ELSE OBS.Mark(120); setCC(x, 0)		END ;		IF ODD(x.a0) THEN OBC.PutF0(x.a0-1) ELSE OBC.PutF0(x.a0+1) END ;		loc := OBC.pc; OBC.PutWord(x.a2); OBC.FixLink(x.a1)	END CFJ;	PROCEDURE BJ*(loc: INTEGER);	BEGIN OBC.PutF0(14); OBC.PutDisp(loc - OBC.pc + 1)	END BJ;	PROCEDURE CBJ*(VAR x: OBT.Item; loc: INTEGER);	BEGIN		IF x.typ.form = Bool THEN			IF x.mode # Coc THEN OBC.PutF2(1CH, 1, x); setCC(x,0) END		ELSE OBS.Mark(120); setCC(x, 0)		END ;		IF ODD(x.a0) THEN OBC.PutF0(x.a0-1) ELSE OBC.PutF0(x.a0+1) END ;		OBC.PutDisp(loc - OBC.pc + 1);		OBC.FixLinkWith(x.a2, loc); OBC.FixLink(x.a1)	END CBJ;	PROCEDURE LFJ*(VAR loc: INTEGER);	BEGIN OBC.PutF0(14); OBC.PutWord(-4000H); OBC.PutWord(0); loc := OBC.pc-4	END LFJ;	PROCEDURE PrepCall*(VAR x: OBT.Item; VAR fpar: OBT.Object);	BEGIN		IF (x.mode = LProc) OR (x.mode = CProc) THEN			fpar := x.obj.dsc		ELSIF (x.typ # NIL) & (x.typ.form = ProcTyp) THEN			fpar := x.typ.link		ELSE OBS.Mark(121); fpar := NIL; x.typ := OBT.undftyp		END	END PrepCall;	PROCEDURE Param*(VAR ap: OBT.Item; f: OBT.Object);		VAR q: OBT.Struct; fp, tag: OBT.Item;	BEGIN fp.mode := Stk; fp.typ := f.typ;		IF f.mode = Ind THEN (*VAR parameter*)			IF ap.mode >= Con THEN OBS.Mark(122) END ;			IF fp.typ.form = DynArr THEN				DynArrBnd(fp.typ, ap.typ, ap.lev, ap.a0, TRUE);				IF ap.typ.form = DynArr THEN OBC.DynArrAdr(fp, ap)				ELSE OBC.PutF4(27H, fp, ap)				END			ELSIF (fp.typ.form = Record) & (ap.typ.form = Record) THEN				q := ap.typ;				WHILE (q # fp.typ) & (q # NIL) DO q := q.BaseTyp END ;				IF q # NIL THEN					IF (ap.mode = Ind) & (ap.obj # NIL) & (ap.obj # OBC.wasderef) THEN						(*actual par is VAR-par*)						ap.mode := Var; ap.a0 := ap.a0 + 4; OBC.PutF4(17H, fp, ap);						ap.a0 := ap.a0 - 4; OBC.PutF4(17H, fp, ap)					ELSIF ((ap.mode = Ind) OR (ap.mode = RegI)) & (ap.obj = OBC.wasderef) THEN						(*actual par is p^*)						ap.a1 := - 4; OBC.PutF4(17H, fp, ap);						IF ap.mode = Ind THEN ap.mode := Var ELSE ap.mode := Reg END;						OBC.PutF4(17H, fp, ap)					ELSE						tag.mode := Var; tag.lev := -ap.typ.mno; tag.a0 := ap.typ.adr;						OBC.PutF4(17H, fp, tag); OBC.PutF4(27H, fp, ap)					END				ELSE OBS.Mark(111)				END			ELSIF (ap.typ = fp.typ) OR ((fp.typ.form = Byte) & (ap.typ.form IN {Char, SInt})) THEN				IF (ap.mode = Ind) & (ap.a1 = 0) THEN (*actual var par*)					ap.mode := Var; OBC.PutF4(17H, fp, ap)				ELSE OBC.PutF4(27H, fp, ap)				END			ELSE OBS.Mark(123)			END		ELSE Assign(fp, ap, TRUE)		END	END Param;	PROCEDURE Call*(VAR x: OBT.Item);		VAR stk, sL: OBT.Item;	BEGIN		IF x.mode = LProc THEN			IF x.lev >= 0 THEN				IF x.lev > 0 THEN					sL.mode := Var; sL.typ := OBT.linttyp; sL.lev := x.lev; sL.a0 := 0;					stk.mode := Stk; OBC.PutF4(27H, stk, sL)  (*static link*)				END ;				OBC.PutF1(2);  (*BSR*)				IF x.a0 = 0 THEN OBC.PutWord(x.a1); x.obj.a1 := OBC.pc - 2 (*forward link*)				ELSE OBC.PutDisp(x.a0 - OBC.pc + 1)				END			ELSE OBC.PutF1(2); OBC.PutExtAdr(-x.lev, x.a0) (*BSR*)			END		ELSIF (x.mode < Con) & (x.typ.form # Undef) THEN			IF (x.mode = Var) & (x.lev > 0) & (x.lev = OBC.level) THEN x.mode := Ind			ELSE load(x); x.mode := RegI			END ;			x.a1 := 0; OBC.PutF2(7FH, 12, x); x.typ := x.typ.BaseTyp  (*JSRD*)		ELSIF x.mode = CProc THEN			OBC.PutF1(0E2H); OBC.PutByte(x.a0)            (*SVC n*)		ELSE OBS.Mark(121)		END		(*function result is marked when restoring registers*)	END Call;	PROCEDURE Enter*(mode: SHORTINT; VAR L: INTEGER);	BEGIN OBC.CheckCodeSize; OBC.PutF1(82H);  (*ENTER*)		IF mode = IProc THEN OBC.PutByte(0C0H) ELSE OBC.PutByte(0) END ;		IF mode = Mod THEN OBC.PutByte(0)		ELSIF stkchk & (mode # IProc) THEN (*check SP against stack limit*)			L := OBC.pc; OBC.PutWord(0);			OBC.PutF3(-47D9H); OBC.PutF3(547H); OBC.PutDisp(3FF0H);  (*ADDR TOS, R0; CMPD R0, lim*)			OBC.PutF0(4); OBC.PutDisp(4); OBC.PutF1(0F2H); OBC.PutByte(14);  (*BHI *+4  BPT 14*)		ELSIF clrchk THEN (*clear local frame*)			OBC.PutByte(0); OBC.PutF3(-57D9H); L := OBC.pc; OBC.PutWord(0);  (*ADDR @n, R0*)			OBC.PutF3(-47A1H); OBC.PutF3(64DH); OBC.PutDisp(-2)   (*MOVQD 0, TOS;  ACBW -4, R0, -2*)		ELSE L := OBC.pc; OBC.PutWord(0)		END	END Enter;	PROCEDURE CopyDynArray*(adr: LONGINT; typ: OBT.Struct);		VAR size, ptr, m2, tos: OBT.Item;		PROCEDURE DynArrSize(typ: OBT.Struct);			VAR len: OBT.Item;		BEGIN			IF typ.form = DynArr THEN DynArrSize(typ.BaseTyp);				len.mode := Var; len.lev := OBC.level; len.typ := OBT.linttyp;				len.a0 := adr + typ.adr; load(len);				IF size.a0 # 1 THEN OBC.Put(F7, 23H, len, size)	(* MULD size, len *) END;				size := len			ELSE size.mode := Con; size.typ := OBT.linttyp; size.a0 := typ.size			END		END DynArrSize;			BEGIN		DynArrSize(typ);	(* load total byte size of dyn array *)		OBC.PutF2(0FH, 3, size);	(* ADDQD 3, size *)		m2.mode := Con; m2.typ := OBT.sinttyp;		m2.a0 := -2; OBC.Put(F6, 7, size, m2);	(* ASHD -2, size *)		ptr.mode := Var; ptr.lev := OBC.level; ptr.typ := OBT.linttyp;		ptr.a0 := adr; load(ptr); 		ptr.mode := RegX; ptr.a1 := -4; ptr.a2 := size.a0; tos.mode := Stk;		OBC.PutF4(17H, tos, ptr);	(* loop:	MOVD -4(ptr)[size:D], TOS *)		OBC.PutF2(4FH, -1, size); OBC.PutDisp(-4);	(* ACBD -1, size, loop *)		OBC.PutF3(-31D9H); OBC.PutDisp(0); OBC.PutDisp(adr);	(* ADDR 0(SP), adr(FP) *)		OBC.FreeRegs({})	END CopyDynArray;		PROCEDURE Result*(VAR x: OBT.Item; typ: OBT.Struct);		VAR res: OBT.Item;	BEGIN res.mode := Reg; res.typ := typ; res.a0 := 0;		Assign(res, x, FALSE)	END Result;	PROCEDURE Return*(mode: INTEGER; psize: LONGINT);	BEGIN OBC.PutF1(92H);                                     (*EXIT*)		IF mode = LProc THEN			OBC.PutByte(0); OBC.PutF1(12H); OBC.PutDisp(psize-8)  (*RET*)		ELSIF mode = IProc THEN			OBC.PutByte(3); OBC.PutF1(42H); OBC.PutDisp(0)        (*RETT 0*)		END	END Return;	PROCEDURE CaseIn*(VAR x: OBT.Item; VAR L0, L1: INTEGER);		VAR f: INTEGER; x0, z: OBT.Item;	BEGIN f := x.typ.form;		IF f = LInt THEN load(x)		ELSIF f = Int THEN x0 := x; OBC.GetReg(x); OBC.Put(F7, 1DH, x, x0)  (*MOVXWD*)		ELSIF f = Char THEN x0 := x; OBC.GetReg(x); OBC.Put(F7, 18H, x, x0)  (*MOVZBD*)		ELSIF f = SInt THEN x0 := x; OBC.GetReg(x); OBC.Put(F7, 1CH, x, x0)  (*MOVXBD*)		ELSE OBS.Mark(125)		END ;		z.mode := Con; z.typ := OBT.linttyp; z.a0 := 0; OBC.PutF4(23H, x, z);   (*SUBi*)		L0 := OBC.pc; OBC.PutF4(7, z, x);   (*CMPi*)		OBC.PutF0(11); OBC.PutWord(0);   (*BHS*)		L1 := OBC.pc; OBC.PutF3(-1083H); OBC.PutByte(x.a0+0D8H); OBC.PutWord(0)  (*CASE*)	END CaseIn;	PROCEDURE CaseOut*(L0, L1, L2, L3, n: INTEGER;										 VAR tab: ARRAY OF LabelRange);		VAR i, j, lim, len: INTEGER; k: LONGINT;	BEGIN (*generate jump table*)		IF ODD(OBC.pc) THEN OBC.PutByte(0A2H) END ;		IF n > 0 THEN len := tab[n-1].high - tab[0].low + 1 ELSE len := 0 END ;		OBC.PutByte(6); OBC.PutF3(len);   (*for decoder*)		OBC.FixupImm(L0, tab[0].low);  (*SUB*)		OBC.FixupImm(L1-3, len);  (*CMP*)		OBC.FixupWith(L1-2, L2-L1+3);  (*out of bounds jump addr*)		OBC.FixupWith(L1+3, OBC.pc-L1);     (*jump address to table*)		i := 0; j := tab[0].low;		WHILE i < n DO			lim := tab[i].high;			WHILE j < tab[i].low DO OBC.PutF3(L2-L1); INC(j) END ;			WHILE j <= lim DO OBC.PutF3(tab[i].label-L1); INC(j) END ;			INC(i)		END ;		OBC.FixLink(L3)	END CaseOut;BEGIN	lengcode[Undef] := 0;	lengcode[Byte] := 0;	lengcode[Bool] := 0;	lengcode[Char] := 0;	lengcode[SInt] := 0;	lengcode[Int] := 1;	lengcode[LInt] := 3;	lengcode[Real] := 1;	lengcode[LReal] := 0;	lengcode[Set] := 3;	lengcode[String] := 0;	lengcode[NilTyp] := 3;	lengcode[ProcTyp] := 3;	lengcode[Pointer] := 3;	lengcode[Array] := 1;	lengcode[DynArr] := 1;	lengcode[Record] := 1;END OBH.